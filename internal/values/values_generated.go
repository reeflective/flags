package values

// This file is autogenerated by "go generate .". Do not modify.

import (
	"encoding/hex"
	"errors"
	"fmt"
	"net"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// mapAllowedKinds stores list of kinds allowed for map keys.
var mapAllowedKinds = []reflect.Kind{
	reflect.String,
	reflect.Int,
	reflect.Int8,
	reflect.Int16,
	reflect.Int32,
	reflect.Int64,
	reflect.Uint,
	reflect.Uint8,
	reflect.Uint16,
	reflect.Uint32,
	reflect.Uint64,
}

// ParseGenerated generates a flag with underlying interface type.
func ParseGenerated(value any, sep *string) Value {
	switch value := value.(type) {
	case *string:
		return newStringValue(value)
	case *bool:
		return newBoolValue(value)
	case *uint:
		return newUintValue(value)
	case *uint8:
		return newUint8Value(value)
	case *uint16:
		return newUint16Value(value)
	case *uint32:
		return newUint32Value(value)
	case *uint64:
		return newUint64Value(value)
	case *int:
		return newIntValue(value)
	case *int8:
		return newInt8Value(value)
	case *int16:
		return newInt16Value(value)
	case *int32:
		return newInt32Value(value)
	case *int64:
		return newInt64Value(value)
	case *float64:
		return newFloat64Value(value)
	case *float32:
		return newFloat32Value(value)
	case *time.Duration:
		return newDurationValue(value)
	case *net.IP:
		return newIPValue(value)
	case *HexBytes:
		return newHexBytesValue(value)
	case *net.TCPAddr:
		return newTCPAddrValue(value)
	case *net.IPNet:
		return newIPNetValue(value)
	case *[]string:
		return newStringSliceValue(value, sep)
	case *[]bool:
		return newBoolSliceValue(value, sep)
	case *[]uint:
		return newUintSliceValue(value, sep)
	case *[]uint8:
		return newUint8SliceValue(value, sep)
	case *[]uint16:
		return newUint16SliceValue(value, sep)
	case *[]uint32:
		return newUint32SliceValue(value, sep)
	case *[]uint64:
		return newUint64SliceValue(value, sep)
	case *[]int:
		return newIntSliceValue(value, sep)
	case *[]int8:
		return newInt8SliceValue(value, sep)
	case *[]int16:
		return newInt16SliceValue(value, sep)
	case *[]int32:
		return newInt32SliceValue(value, sep)
	case *[]int64:
		return newInt64SliceValue(value, sep)
	case *[]float64:
		return newFloat64SliceValue(value, sep)
	case *[]float32:
		return newFloat32SliceValue(value, sep)
	case *[]time.Duration:
		return newDurationSliceValue(value, sep)
	case *[]net.IP:
		return newIPSliceValue(value, sep)
	case *[]HexBytes:
		return newHexBytesSliceValue(value, sep)
	case *[]*regexp.Regexp:
		return newRegexpSliceValue(value, sep)
	case *[]net.TCPAddr:
		return newTCPAddrSliceValue(value, sep)
	case *[]net.IPNet:
		return newIPNetSliceValue(value, sep)

	default:
		return nil
	}
}

// ParseGenerated generates a flag with underlying ptr type.
func ParseGeneratedPtrs(value any) Value {
	switch value := value.(type) {

	case **regexp.Regexp:
		return newRegexpValue(value)

	default:
		return nil
	}
}

// ParseGenerated generates a flag with underlying map type.
func ParseGeneratedMap(value any, sep *string) Value {
	switch value := value.(type) {

	case *map[string]string:
		return newStringStringMapValue(value, sep)

	case *map[int]string:
		return newIntStringMapValue(value, sep)

	case *map[int8]string:
		return newInt8StringMapValue(value, sep)

	case *map[int16]string:
		return newInt16StringMapValue(value, sep)

	case *map[int32]string:
		return newInt32StringMapValue(value, sep)

	case *map[int64]string:
		return newInt64StringMapValue(value, sep)

	case *map[uint]string:
		return newUintStringMapValue(value, sep)

	case *map[uint8]string:
		return newUint8StringMapValue(value, sep)

	case *map[uint16]string:
		return newUint16StringMapValue(value, sep)

	case *map[uint32]string:
		return newUint32StringMapValue(value, sep)

	case *map[uint64]string:
		return newUint64StringMapValue(value, sep)

	case *map[string]bool:
		return newStringBoolMapValue(value, sep)

	case *map[int]bool:
		return newIntBoolMapValue(value, sep)

	case *map[int8]bool:
		return newInt8BoolMapValue(value, sep)

	case *map[int16]bool:
		return newInt16BoolMapValue(value, sep)

	case *map[int32]bool:
		return newInt32BoolMapValue(value, sep)

	case *map[int64]bool:
		return newInt64BoolMapValue(value, sep)

	case *map[uint]bool:
		return newUintBoolMapValue(value, sep)

	case *map[uint8]bool:
		return newUint8BoolMapValue(value, sep)

	case *map[uint16]bool:
		return newUint16BoolMapValue(value, sep)

	case *map[uint32]bool:
		return newUint32BoolMapValue(value, sep)

	case *map[uint64]bool:
		return newUint64BoolMapValue(value, sep)

	case *map[string]uint:
		return newStringUintMapValue(value, sep)

	case *map[int]uint:
		return newIntUintMapValue(value, sep)

	case *map[int8]uint:
		return newInt8UintMapValue(value, sep)

	case *map[int16]uint:
		return newInt16UintMapValue(value, sep)

	case *map[int32]uint:
		return newInt32UintMapValue(value, sep)

	case *map[int64]uint:
		return newInt64UintMapValue(value, sep)

	case *map[uint]uint:
		return newUintUintMapValue(value, sep)

	case *map[uint8]uint:
		return newUint8UintMapValue(value, sep)

	case *map[uint16]uint:
		return newUint16UintMapValue(value, sep)

	case *map[uint32]uint:
		return newUint32UintMapValue(value, sep)

	case *map[uint64]uint:
		return newUint64UintMapValue(value, sep)

	case *map[string]uint8:
		return newStringUint8MapValue(value, sep)

	case *map[int]uint8:
		return newIntUint8MapValue(value, sep)

	case *map[int8]uint8:
		return newInt8Uint8MapValue(value, sep)

	case *map[int16]uint8:
		return newInt16Uint8MapValue(value, sep)

	case *map[int32]uint8:
		return newInt32Uint8MapValue(value, sep)

	case *map[int64]uint8:
		return newInt64Uint8MapValue(value, sep)

	case *map[uint]uint8:
		return newUintUint8MapValue(value, sep)

	case *map[uint8]uint8:
		return newUint8Uint8MapValue(value, sep)

	case *map[uint16]uint8:
		return newUint16Uint8MapValue(value, sep)

	case *map[uint32]uint8:
		return newUint32Uint8MapValue(value, sep)

	case *map[uint64]uint8:
		return newUint64Uint8MapValue(value, sep)

	case *map[string]uint16:
		return newStringUint16MapValue(value, sep)

	case *map[int]uint16:
		return newIntUint16MapValue(value, sep)

	case *map[int8]uint16:
		return newInt8Uint16MapValue(value, sep)

	case *map[int16]uint16:
		return newInt16Uint16MapValue(value, sep)

	case *map[int32]uint16:
		return newInt32Uint16MapValue(value, sep)

	case *map[int64]uint16:
		return newInt64Uint16MapValue(value, sep)

	case *map[uint]uint16:
		return newUintUint16MapValue(value, sep)

	case *map[uint8]uint16:
		return newUint8Uint16MapValue(value, sep)

	case *map[uint16]uint16:
		return newUint16Uint16MapValue(value, sep)

	case *map[uint32]uint16:
		return newUint32Uint16MapValue(value, sep)

	case *map[uint64]uint16:
		return newUint64Uint16MapValue(value, sep)

	case *map[string]uint32:
		return newStringUint32MapValue(value, sep)

	case *map[int]uint32:
		return newIntUint32MapValue(value, sep)

	case *map[int8]uint32:
		return newInt8Uint32MapValue(value, sep)

	case *map[int16]uint32:
		return newInt16Uint32MapValue(value, sep)

	case *map[int32]uint32:
		return newInt32Uint32MapValue(value, sep)

	case *map[int64]uint32:
		return newInt64Uint32MapValue(value, sep)

	case *map[uint]uint32:
		return newUintUint32MapValue(value, sep)

	case *map[uint8]uint32:
		return newUint8Uint32MapValue(value, sep)

	case *map[uint16]uint32:
		return newUint16Uint32MapValue(value, sep)

	case *map[uint32]uint32:
		return newUint32Uint32MapValue(value, sep)

	case *map[uint64]uint32:
		return newUint64Uint32MapValue(value, sep)

	case *map[string]uint64:
		return newStringUint64MapValue(value, sep)

	case *map[int]uint64:
		return newIntUint64MapValue(value, sep)

	case *map[int8]uint64:
		return newInt8Uint64MapValue(value, sep)

	case *map[int16]uint64:
		return newInt16Uint64MapValue(value, sep)

	case *map[int32]uint64:
		return newInt32Uint64MapValue(value, sep)

	case *map[int64]uint64:
		return newInt64Uint64MapValue(value, sep)

	case *map[uint]uint64:
		return newUintUint64MapValue(value, sep)

	case *map[uint8]uint64:
		return newUint8Uint64MapValue(value, sep)

	case *map[uint16]uint64:
		return newUint16Uint64MapValue(value, sep)

	case *map[uint32]uint64:
		return newUint32Uint64MapValue(value, sep)

	case *map[uint64]uint64:
		return newUint64Uint64MapValue(value, sep)

	case *map[string]int:
		return newStringIntMapValue(value, sep)

	case *map[int]int:
		return newIntIntMapValue(value, sep)

	case *map[int8]int:
		return newInt8IntMapValue(value, sep)

	case *map[int16]int:
		return newInt16IntMapValue(value, sep)

	case *map[int32]int:
		return newInt32IntMapValue(value, sep)

	case *map[int64]int:
		return newInt64IntMapValue(value, sep)

	case *map[uint]int:
		return newUintIntMapValue(value, sep)

	case *map[uint8]int:
		return newUint8IntMapValue(value, sep)

	case *map[uint16]int:
		return newUint16IntMapValue(value, sep)

	case *map[uint32]int:
		return newUint32IntMapValue(value, sep)

	case *map[uint64]int:
		return newUint64IntMapValue(value, sep)

	case *map[string]int8:
		return newStringInt8MapValue(value, sep)

	case *map[int]int8:
		return newIntInt8MapValue(value, sep)

	case *map[int8]int8:
		return newInt8Int8MapValue(value, sep)

	case *map[int16]int8:
		return newInt16Int8MapValue(value, sep)

	case *map[int32]int8:
		return newInt32Int8MapValue(value, sep)

	case *map[int64]int8:
		return newInt64Int8MapValue(value, sep)

	case *map[uint]int8:
		return newUintInt8MapValue(value, sep)

	case *map[uint8]int8:
		return newUint8Int8MapValue(value, sep)

	case *map[uint16]int8:
		return newUint16Int8MapValue(value, sep)

	case *map[uint32]int8:
		return newUint32Int8MapValue(value, sep)

	case *map[uint64]int8:
		return newUint64Int8MapValue(value, sep)

	case *map[string]int16:
		return newStringInt16MapValue(value, sep)

	case *map[int]int16:
		return newIntInt16MapValue(value, sep)

	case *map[int8]int16:
		return newInt8Int16MapValue(value, sep)

	case *map[int16]int16:
		return newInt16Int16MapValue(value, sep)

	case *map[int32]int16:
		return newInt32Int16MapValue(value, sep)

	case *map[int64]int16:
		return newInt64Int16MapValue(value, sep)

	case *map[uint]int16:
		return newUintInt16MapValue(value, sep)

	case *map[uint8]int16:
		return newUint8Int16MapValue(value, sep)

	case *map[uint16]int16:
		return newUint16Int16MapValue(value, sep)

	case *map[uint32]int16:
		return newUint32Int16MapValue(value, sep)

	case *map[uint64]int16:
		return newUint64Int16MapValue(value, sep)

	case *map[string]int32:
		return newStringInt32MapValue(value, sep)

	case *map[int]int32:
		return newIntInt32MapValue(value, sep)

	case *map[int8]int32:
		return newInt8Int32MapValue(value, sep)

	case *map[int16]int32:
		return newInt16Int32MapValue(value, sep)

	case *map[int32]int32:
		return newInt32Int32MapValue(value, sep)

	case *map[int64]int32:
		return newInt64Int32MapValue(value, sep)

	case *map[uint]int32:
		return newUintInt32MapValue(value, sep)

	case *map[uint8]int32:
		return newUint8Int32MapValue(value, sep)

	case *map[uint16]int32:
		return newUint16Int32MapValue(value, sep)

	case *map[uint32]int32:
		return newUint32Int32MapValue(value, sep)

	case *map[uint64]int32:
		return newUint64Int32MapValue(value, sep)

	case *map[string]int64:
		return newStringInt64MapValue(value, sep)

	case *map[int]int64:
		return newIntInt64MapValue(value, sep)

	case *map[int8]int64:
		return newInt8Int64MapValue(value, sep)

	case *map[int16]int64:
		return newInt16Int64MapValue(value, sep)

	case *map[int32]int64:
		return newInt32Int64MapValue(value, sep)

	case *map[int64]int64:
		return newInt64Int64MapValue(value, sep)

	case *map[uint]int64:
		return newUintInt64MapValue(value, sep)

	case *map[uint8]int64:
		return newUint8Int64MapValue(value, sep)

	case *map[uint16]int64:
		return newUint16Int64MapValue(value, sep)

	case *map[uint32]int64:
		return newUint32Int64MapValue(value, sep)

	case *map[uint64]int64:
		return newUint64Int64MapValue(value, sep)

	case *map[string]float64:
		return newStringFloat64MapValue(value, sep)

	case *map[int]float64:
		return newIntFloat64MapValue(value, sep)

	case *map[int8]float64:
		return newInt8Float64MapValue(value, sep)

	case *map[int16]float64:
		return newInt16Float64MapValue(value, sep)

	case *map[int32]float64:
		return newInt32Float64MapValue(value, sep)

	case *map[int64]float64:
		return newInt64Float64MapValue(value, sep)

	case *map[uint]float64:
		return newUintFloat64MapValue(value, sep)

	case *map[uint8]float64:
		return newUint8Float64MapValue(value, sep)

	case *map[uint16]float64:
		return newUint16Float64MapValue(value, sep)

	case *map[uint32]float64:
		return newUint32Float64MapValue(value, sep)

	case *map[uint64]float64:
		return newUint64Float64MapValue(value, sep)

	case *map[string]float32:
		return newStringFloat32MapValue(value, sep)

	case *map[int]float32:
		return newIntFloat32MapValue(value, sep)

	case *map[int8]float32:
		return newInt8Float32MapValue(value, sep)

	case *map[int16]float32:
		return newInt16Float32MapValue(value, sep)

	case *map[int32]float32:
		return newInt32Float32MapValue(value, sep)

	case *map[int64]float32:
		return newInt64Float32MapValue(value, sep)

	case *map[uint]float32:
		return newUintFloat32MapValue(value, sep)

	case *map[uint8]float32:
		return newUint8Float32MapValue(value, sep)

	case *map[uint16]float32:
		return newUint16Float32MapValue(value, sep)

	case *map[uint32]float32:
		return newUint32Float32MapValue(value, sep)

	case *map[uint64]float32:
		return newUint64Float32MapValue(value, sep)

	case *map[string]time.Duration:
		return newStringDurationMapValue(value, sep)

	case *map[int]time.Duration:
		return newIntDurationMapValue(value, sep)

	case *map[int8]time.Duration:
		return newInt8DurationMapValue(value, sep)

	case *map[int16]time.Duration:
		return newInt16DurationMapValue(value, sep)

	case *map[int32]time.Duration:
		return newInt32DurationMapValue(value, sep)

	case *map[int64]time.Duration:
		return newInt64DurationMapValue(value, sep)

	case *map[uint]time.Duration:
		return newUintDurationMapValue(value, sep)

	case *map[uint8]time.Duration:
		return newUint8DurationMapValue(value, sep)

	case *map[uint16]time.Duration:
		return newUint16DurationMapValue(value, sep)

	case *map[uint32]time.Duration:
		return newUint32DurationMapValue(value, sep)

	case *map[uint64]time.Duration:
		return newUint64DurationMapValue(value, sep)

	case *map[string]net.IP:
		return newStringIPMapValue(value, sep)

	case *map[int]net.IP:
		return newIntIPMapValue(value, sep)

	case *map[int8]net.IP:
		return newInt8IPMapValue(value, sep)

	case *map[int16]net.IP:
		return newInt16IPMapValue(value, sep)

	case *map[int32]net.IP:
		return newInt32IPMapValue(value, sep)

	case *map[int64]net.IP:
		return newInt64IPMapValue(value, sep)

	case *map[uint]net.IP:
		return newUintIPMapValue(value, sep)

	case *map[uint8]net.IP:
		return newUint8IPMapValue(value, sep)

	case *map[uint16]net.IP:
		return newUint16IPMapValue(value, sep)

	case *map[uint32]net.IP:
		return newUint32IPMapValue(value, sep)

	case *map[uint64]net.IP:
		return newUint64IPMapValue(value, sep)

	case *map[string]HexBytes:
		return newStringHexBytesMapValue(value, sep)

	case *map[int]HexBytes:
		return newIntHexBytesMapValue(value, sep)

	case *map[int8]HexBytes:
		return newInt8HexBytesMapValue(value, sep)

	case *map[int16]HexBytes:
		return newInt16HexBytesMapValue(value, sep)

	case *map[int32]HexBytes:
		return newInt32HexBytesMapValue(value, sep)

	case *map[int64]HexBytes:
		return newInt64HexBytesMapValue(value, sep)

	case *map[uint]HexBytes:
		return newUintHexBytesMapValue(value, sep)

	case *map[uint8]HexBytes:
		return newUint8HexBytesMapValue(value, sep)

	case *map[uint16]HexBytes:
		return newUint16HexBytesMapValue(value, sep)

	case *map[uint32]HexBytes:
		return newUint32HexBytesMapValue(value, sep)

	case *map[uint64]HexBytes:
		return newUint64HexBytesMapValue(value, sep)

	case *map[string]*regexp.Regexp:
		return newStringRegexpMapValue(value, sep)

	case *map[int]*regexp.Regexp:
		return newIntRegexpMapValue(value, sep)

	case *map[int8]*regexp.Regexp:
		return newInt8RegexpMapValue(value, sep)

	case *map[int16]*regexp.Regexp:
		return newInt16RegexpMapValue(value, sep)

	case *map[int32]*regexp.Regexp:
		return newInt32RegexpMapValue(value, sep)

	case *map[int64]*regexp.Regexp:
		return newInt64RegexpMapValue(value, sep)

	case *map[uint]*regexp.Regexp:
		return newUintRegexpMapValue(value, sep)

	case *map[uint8]*regexp.Regexp:
		return newUint8RegexpMapValue(value, sep)

	case *map[uint16]*regexp.Regexp:
		return newUint16RegexpMapValue(value, sep)

	case *map[uint32]*regexp.Regexp:
		return newUint32RegexpMapValue(value, sep)

	case *map[uint64]*regexp.Regexp:
		return newUint64RegexpMapValue(value, sep)

	case *map[string]net.IPNet:
		return newStringIPNetMapValue(value, sep)

	case *map[int]net.IPNet:
		return newIntIPNetMapValue(value, sep)

	case *map[int8]net.IPNet:
		return newInt8IPNetMapValue(value, sep)

	case *map[int16]net.IPNet:
		return newInt16IPNetMapValue(value, sep)

	case *map[int32]net.IPNet:
		return newInt32IPNetMapValue(value, sep)

	case *map[int64]net.IPNet:
		return newInt64IPNetMapValue(value, sep)

	case *map[uint]net.IPNet:
		return newUintIPNetMapValue(value, sep)

	case *map[uint8]net.IPNet:
		return newUint8IPNetMapValue(value, sep)

	case *map[uint16]net.IPNet:
		return newUint16IPNetMapValue(value, sep)

	case *map[uint32]net.IPNet:
		return newUint32IPNetMapValue(value, sep)

	case *map[uint64]net.IPNet:
		return newUint64IPNetMapValue(value, sep)

	default:
		return nil
	}
}

// -- string Value.
type stringValue struct {
	value *string
}

var _ Value = (*stringValue)(nil)
var _ Getter = (*stringValue)(nil)

func newStringValue(p *string) *stringValue {
	return &stringValue{value: p}
}

func (v *stringValue) Set(s string) error {

	*v.value = s

	return nil

}

func (v *stringValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *stringValue) String() string {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ""
}

func (v *stringValue) Type() string { return "string" }

// -- stringSlice Value

type stringSliceValue struct {
	value     *[]string
	changed   bool
	separator string
}

var _ RepeatableFlag = (*stringSliceValue)(nil)
var _ Value = (*stringSliceValue)(nil)
var _ Getter = (*stringSliceValue)(nil)

func newStringSliceValue(slice *[]string, sep *string) *stringSliceValue {
	s := &stringSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := ss
	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *stringSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]string)(nil)
}

func (v *stringSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newStringValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *stringSliceValue) Type() string { return "stringSlice" }

func (v *stringSliceValue) IsCumulative() bool {
	return true
}

// -- stringStringMapValue.
type stringStringMapValue struct {
	value     *map[string]string
	separator string
}

var _ RepeatableFlag = (*stringStringMapValue)(nil)
var _ Value = (*stringStringMapValue)(nil)
var _ Getter = (*stringStringMapValue)(nil)

func newStringStringMapValue(m *map[string]string, sep *string) *stringStringMapValue {
	s := &stringStringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringStringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringStringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringStringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringStringMapValue) Type() string { return "map[string]string" }

func (v *stringStringMapValue) IsCumulative() bool {
	return true
}

// -- intStringMapValue.
type intStringMapValue struct {
	value     *map[int]string
	separator string
}

var _ RepeatableFlag = (*intStringMapValue)(nil)
var _ Value = (*intStringMapValue)(nil)
var _ Getter = (*intStringMapValue)(nil)

func newIntStringMapValue(m *map[int]string, sep *string) *intStringMapValue {
	s := &intStringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intStringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *intStringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intStringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intStringMapValue) Type() string { return "map[int]string" }

func (v *intStringMapValue) IsCumulative() bool {
	return true
}

// -- int8StringMapValue.
type int8StringMapValue struct {
	value     *map[int8]string
	separator string
}

var _ RepeatableFlag = (*int8StringMapValue)(nil)
var _ Value = (*int8StringMapValue)(nil)
var _ Getter = (*int8StringMapValue)(nil)

func newInt8StringMapValue(m *map[int8]string, sep *string) *int8StringMapValue {
	s := &int8StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8StringMapValue) Type() string { return "map[int8]string" }

func (v *int8StringMapValue) IsCumulative() bool {
	return true
}

// -- int16StringMapValue.
type int16StringMapValue struct {
	value     *map[int16]string
	separator string
}

var _ RepeatableFlag = (*int16StringMapValue)(nil)
var _ Value = (*int16StringMapValue)(nil)
var _ Getter = (*int16StringMapValue)(nil)

func newInt16StringMapValue(m *map[int16]string, sep *string) *int16StringMapValue {
	s := &int16StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16StringMapValue) Type() string { return "map[int16]string" }

func (v *int16StringMapValue) IsCumulative() bool {
	return true
}

// -- int32StringMapValue.
type int32StringMapValue struct {
	value     *map[int32]string
	separator string
}

var _ RepeatableFlag = (*int32StringMapValue)(nil)
var _ Value = (*int32StringMapValue)(nil)
var _ Getter = (*int32StringMapValue)(nil)

func newInt32StringMapValue(m *map[int32]string, sep *string) *int32StringMapValue {
	s := &int32StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32StringMapValue) Type() string { return "map[int32]string" }

func (v *int32StringMapValue) IsCumulative() bool {
	return true
}

// -- int64StringMapValue.
type int64StringMapValue struct {
	value     *map[int64]string
	separator string
}

var _ RepeatableFlag = (*int64StringMapValue)(nil)
var _ Value = (*int64StringMapValue)(nil)
var _ Getter = (*int64StringMapValue)(nil)

func newInt64StringMapValue(m *map[int64]string, sep *string) *int64StringMapValue {
	s := &int64StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64StringMapValue) Type() string { return "map[int64]string" }

func (v *int64StringMapValue) IsCumulative() bool {
	return true
}

// -- uintStringMapValue.
type uintStringMapValue struct {
	value     *map[uint]string
	separator string
}

var _ RepeatableFlag = (*uintStringMapValue)(nil)
var _ Value = (*uintStringMapValue)(nil)
var _ Getter = (*uintStringMapValue)(nil)

func newUintStringMapValue(m *map[uint]string, sep *string) *uintStringMapValue {
	s := &uintStringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintStringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintStringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintStringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintStringMapValue) Type() string { return "map[uint]string" }

func (v *uintStringMapValue) IsCumulative() bool {
	return true
}

// -- uint8StringMapValue.
type uint8StringMapValue struct {
	value     *map[uint8]string
	separator string
}

var _ RepeatableFlag = (*uint8StringMapValue)(nil)
var _ Value = (*uint8StringMapValue)(nil)
var _ Getter = (*uint8StringMapValue)(nil)

func newUint8StringMapValue(m *map[uint8]string, sep *string) *uint8StringMapValue {
	s := &uint8StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8StringMapValue) Type() string { return "map[uint8]string" }

func (v *uint8StringMapValue) IsCumulative() bool {
	return true
}

// -- uint16StringMapValue.
type uint16StringMapValue struct {
	value     *map[uint16]string
	separator string
}

var _ RepeatableFlag = (*uint16StringMapValue)(nil)
var _ Value = (*uint16StringMapValue)(nil)
var _ Getter = (*uint16StringMapValue)(nil)

func newUint16StringMapValue(m *map[uint16]string, sep *string) *uint16StringMapValue {
	s := &uint16StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16StringMapValue) Type() string { return "map[uint16]string" }

func (v *uint16StringMapValue) IsCumulative() bool {
	return true
}

// -- uint32StringMapValue.
type uint32StringMapValue struct {
	value     *map[uint32]string
	separator string
}

var _ RepeatableFlag = (*uint32StringMapValue)(nil)
var _ Value = (*uint32StringMapValue)(nil)
var _ Getter = (*uint32StringMapValue)(nil)

func newUint32StringMapValue(m *map[uint32]string, sep *string) *uint32StringMapValue {
	s := &uint32StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32StringMapValue) Type() string { return "map[uint32]string" }

func (v *uint32StringMapValue) IsCumulative() bool {
	return true
}

// -- uint64StringMapValue.
type uint64StringMapValue struct {
	value     *map[uint64]string
	separator string
}

var _ RepeatableFlag = (*uint64StringMapValue)(nil)
var _ Value = (*uint64StringMapValue)(nil)
var _ Getter = (*uint64StringMapValue)(nil)

func newUint64StringMapValue(m *map[uint64]string, sep *string) *uint64StringMapValue {
	s := &uint64StringMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64StringMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		val := s

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64StringMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64StringMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64StringMapValue) Type() string { return "map[uint64]string" }

func (v *uint64StringMapValue) IsCumulative() bool {
	return true
}

// -- bool Value.
type boolValue struct {
	value *bool
}

var _ Value = (*boolValue)(nil)
var _ Getter = (*boolValue)(nil)

func newBoolValue(p *bool) *boolValue {
	return &boolValue{value: p}
}

func (v *boolValue) Set(s string) error {

	parsed, err := strconv.ParseBool(s)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *boolValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *boolValue) String() string {
	if v != nil && v.value != nil {

		return strconv.FormatBool(*v.value)
	}

	return ""
}

func (v *boolValue) Type() string { return "bool" }

// -- boolSlice Value

type boolSliceValue struct {
	value     *[]bool
	changed   bool
	separator string
}

var _ RepeatableFlag = (*boolSliceValue)(nil)
var _ Value = (*boolSliceValue)(nil)
var _ Getter = (*boolSliceValue)(nil)

func newBoolSliceValue(slice *[]bool, sep *string) *boolSliceValue {
	s := &boolSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *boolSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]bool, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *boolSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]bool)(nil)
}

func (v *boolSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newBoolValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *boolSliceValue) Type() string { return "boolSlice" }

func (v *boolSliceValue) IsCumulative() bool {
	return true
}

// -- stringBoolMapValue.
type stringBoolMapValue struct {
	value     *map[string]bool
	separator string
}

var _ RepeatableFlag = (*stringBoolMapValue)(nil)
var _ Value = (*stringBoolMapValue)(nil)
var _ Getter = (*stringBoolMapValue)(nil)

func newStringBoolMapValue(m *map[string]bool, sep *string) *stringBoolMapValue {
	s := &stringBoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringBoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringBoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringBoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringBoolMapValue) Type() string { return "map[string]bool" }

func (v *stringBoolMapValue) IsCumulative() bool {
	return true
}

// -- intBoolMapValue.
type intBoolMapValue struct {
	value     *map[int]bool
	separator string
}

var _ RepeatableFlag = (*intBoolMapValue)(nil)
var _ Value = (*intBoolMapValue)(nil)
var _ Getter = (*intBoolMapValue)(nil)

func newIntBoolMapValue(m *map[int]bool, sep *string) *intBoolMapValue {
	s := &intBoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intBoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intBoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intBoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intBoolMapValue) Type() string { return "map[int]bool" }

func (v *intBoolMapValue) IsCumulative() bool {
	return true
}

// -- int8BoolMapValue.
type int8BoolMapValue struct {
	value     *map[int8]bool
	separator string
}

var _ RepeatableFlag = (*int8BoolMapValue)(nil)
var _ Value = (*int8BoolMapValue)(nil)
var _ Getter = (*int8BoolMapValue)(nil)

func newInt8BoolMapValue(m *map[int8]bool, sep *string) *int8BoolMapValue {
	s := &int8BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8BoolMapValue) Type() string { return "map[int8]bool" }

func (v *int8BoolMapValue) IsCumulative() bool {
	return true
}

// -- int16BoolMapValue.
type int16BoolMapValue struct {
	value     *map[int16]bool
	separator string
}

var _ RepeatableFlag = (*int16BoolMapValue)(nil)
var _ Value = (*int16BoolMapValue)(nil)
var _ Getter = (*int16BoolMapValue)(nil)

func newInt16BoolMapValue(m *map[int16]bool, sep *string) *int16BoolMapValue {
	s := &int16BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16BoolMapValue) Type() string { return "map[int16]bool" }

func (v *int16BoolMapValue) IsCumulative() bool {
	return true
}

// -- int32BoolMapValue.
type int32BoolMapValue struct {
	value     *map[int32]bool
	separator string
}

var _ RepeatableFlag = (*int32BoolMapValue)(nil)
var _ Value = (*int32BoolMapValue)(nil)
var _ Getter = (*int32BoolMapValue)(nil)

func newInt32BoolMapValue(m *map[int32]bool, sep *string) *int32BoolMapValue {
	s := &int32BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32BoolMapValue) Type() string { return "map[int32]bool" }

func (v *int32BoolMapValue) IsCumulative() bool {
	return true
}

// -- int64BoolMapValue.
type int64BoolMapValue struct {
	value     *map[int64]bool
	separator string
}

var _ RepeatableFlag = (*int64BoolMapValue)(nil)
var _ Value = (*int64BoolMapValue)(nil)
var _ Getter = (*int64BoolMapValue)(nil)

func newInt64BoolMapValue(m *map[int64]bool, sep *string) *int64BoolMapValue {
	s := &int64BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64BoolMapValue) Type() string { return "map[int64]bool" }

func (v *int64BoolMapValue) IsCumulative() bool {
	return true
}

// -- uintBoolMapValue.
type uintBoolMapValue struct {
	value     *map[uint]bool
	separator string
}

var _ RepeatableFlag = (*uintBoolMapValue)(nil)
var _ Value = (*uintBoolMapValue)(nil)
var _ Getter = (*uintBoolMapValue)(nil)

func newUintBoolMapValue(m *map[uint]bool, sep *string) *uintBoolMapValue {
	s := &uintBoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintBoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintBoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintBoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintBoolMapValue) Type() string { return "map[uint]bool" }

func (v *uintBoolMapValue) IsCumulative() bool {
	return true
}

// -- uint8BoolMapValue.
type uint8BoolMapValue struct {
	value     *map[uint8]bool
	separator string
}

var _ RepeatableFlag = (*uint8BoolMapValue)(nil)
var _ Value = (*uint8BoolMapValue)(nil)
var _ Getter = (*uint8BoolMapValue)(nil)

func newUint8BoolMapValue(m *map[uint8]bool, sep *string) *uint8BoolMapValue {
	s := &uint8BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8BoolMapValue) Type() string { return "map[uint8]bool" }

func (v *uint8BoolMapValue) IsCumulative() bool {
	return true
}

// -- uint16BoolMapValue.
type uint16BoolMapValue struct {
	value     *map[uint16]bool
	separator string
}

var _ RepeatableFlag = (*uint16BoolMapValue)(nil)
var _ Value = (*uint16BoolMapValue)(nil)
var _ Getter = (*uint16BoolMapValue)(nil)

func newUint16BoolMapValue(m *map[uint16]bool, sep *string) *uint16BoolMapValue {
	s := &uint16BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16BoolMapValue) Type() string { return "map[uint16]bool" }

func (v *uint16BoolMapValue) IsCumulative() bool {
	return true
}

// -- uint32BoolMapValue.
type uint32BoolMapValue struct {
	value     *map[uint32]bool
	separator string
}

var _ RepeatableFlag = (*uint32BoolMapValue)(nil)
var _ Value = (*uint32BoolMapValue)(nil)
var _ Getter = (*uint32BoolMapValue)(nil)

func newUint32BoolMapValue(m *map[uint32]bool, sep *string) *uint32BoolMapValue {
	s := &uint32BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32BoolMapValue) Type() string { return "map[uint32]bool" }

func (v *uint32BoolMapValue) IsCumulative() bool {
	return true
}

// -- uint64BoolMapValue.
type uint64BoolMapValue struct {
	value     *map[uint64]bool
	separator string
}

var _ RepeatableFlag = (*uint64BoolMapValue)(nil)
var _ Value = (*uint64BoolMapValue)(nil)
var _ Getter = (*uint64BoolMapValue)(nil)

func newUint64BoolMapValue(m *map[uint64]bool, sep *string) *uint64BoolMapValue {
	s := &uint64BoolMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64BoolMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64BoolMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64BoolMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64BoolMapValue) Type() string { return "map[uint64]bool" }

func (v *uint64BoolMapValue) IsCumulative() bool {
	return true
}

// -- uint Value.
type uintValue struct {
	value *uint
}

var _ Value = (*uintValue)(nil)
var _ Getter = (*uintValue)(nil)

func newUintValue(p *uint) *uintValue {
	return &uintValue{value: p}
}

func (v *uintValue) Set(s string) error {

	parsed, err := strconv.ParseUint(s, 0, 64)
	if err == nil {

		*v.value = (uint)(parsed)

		return nil
	}

	return err

}

func (v *uintValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *uintValue) String() string {
	if v != nil && v.value != nil {

		return strconv.FormatUint(uint64(*v.value), 10)
	}

	return ""
}

func (v *uintValue) Type() string { return "uint" }

// -- uintSlice Value

type uintSliceValue struct {
	value     *[]uint
	changed   bool
	separator string
}

var _ RepeatableFlag = (*uintSliceValue)(nil)
var _ Value = (*uintSliceValue)(nil)
var _ Getter = (*uintSliceValue)(nil)

func newUintSliceValue(slice *[]uint, sep *string) *uintSliceValue {
	s := &uintSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]uint, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		out[i] = (uint)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *uintSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]uint)(nil)
}

func (v *uintSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUintValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *uintSliceValue) Type() string { return "uintSlice" }

func (v *uintSliceValue) IsCumulative() bool {
	return true
}

// -- stringUintMapValue.
type stringUintMapValue struct {
	value     *map[string]uint
	separator string
}

var _ RepeatableFlag = (*stringUintMapValue)(nil)
var _ Value = (*stringUintMapValue)(nil)
var _ Getter = (*stringUintMapValue)(nil)

func newStringUintMapValue(m *map[string]uint, sep *string) *stringUintMapValue {
	s := &stringUintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringUintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringUintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringUintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringUintMapValue) Type() string { return "map[string]uint" }

func (v *stringUintMapValue) IsCumulative() bool {
	return true
}

// -- intUintMapValue.
type intUintMapValue struct {
	value     *map[int]uint
	separator string
}

var _ RepeatableFlag = (*intUintMapValue)(nil)
var _ Value = (*intUintMapValue)(nil)
var _ Getter = (*intUintMapValue)(nil)

func newIntUintMapValue(m *map[int]uint, sep *string) *intUintMapValue {
	s := &intUintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intUintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intUintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intUintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intUintMapValue) Type() string { return "map[int]uint" }

func (v *intUintMapValue) IsCumulative() bool {
	return true
}

// -- int8UintMapValue.
type int8UintMapValue struct {
	value     *map[int8]uint
	separator string
}

var _ RepeatableFlag = (*int8UintMapValue)(nil)
var _ Value = (*int8UintMapValue)(nil)
var _ Getter = (*int8UintMapValue)(nil)

func newInt8UintMapValue(m *map[int8]uint, sep *string) *int8UintMapValue {
	s := &int8UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8UintMapValue) Type() string { return "map[int8]uint" }

func (v *int8UintMapValue) IsCumulative() bool {
	return true
}

// -- int16UintMapValue.
type int16UintMapValue struct {
	value     *map[int16]uint
	separator string
}

var _ RepeatableFlag = (*int16UintMapValue)(nil)
var _ Value = (*int16UintMapValue)(nil)
var _ Getter = (*int16UintMapValue)(nil)

func newInt16UintMapValue(m *map[int16]uint, sep *string) *int16UintMapValue {
	s := &int16UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16UintMapValue) Type() string { return "map[int16]uint" }

func (v *int16UintMapValue) IsCumulative() bool {
	return true
}

// -- int32UintMapValue.
type int32UintMapValue struct {
	value     *map[int32]uint
	separator string
}

var _ RepeatableFlag = (*int32UintMapValue)(nil)
var _ Value = (*int32UintMapValue)(nil)
var _ Getter = (*int32UintMapValue)(nil)

func newInt32UintMapValue(m *map[int32]uint, sep *string) *int32UintMapValue {
	s := &int32UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32UintMapValue) Type() string { return "map[int32]uint" }

func (v *int32UintMapValue) IsCumulative() bool {
	return true
}

// -- int64UintMapValue.
type int64UintMapValue struct {
	value     *map[int64]uint
	separator string
}

var _ RepeatableFlag = (*int64UintMapValue)(nil)
var _ Value = (*int64UintMapValue)(nil)
var _ Getter = (*int64UintMapValue)(nil)

func newInt64UintMapValue(m *map[int64]uint, sep *string) *int64UintMapValue {
	s := &int64UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64UintMapValue) Type() string { return "map[int64]uint" }

func (v *int64UintMapValue) IsCumulative() bool {
	return true
}

// -- uintUintMapValue.
type uintUintMapValue struct {
	value     *map[uint]uint
	separator string
}

var _ RepeatableFlag = (*uintUintMapValue)(nil)
var _ Value = (*uintUintMapValue)(nil)
var _ Getter = (*uintUintMapValue)(nil)

func newUintUintMapValue(m *map[uint]uint, sep *string) *uintUintMapValue {
	s := &uintUintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintUintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintUintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintUintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintUintMapValue) Type() string { return "map[uint]uint" }

func (v *uintUintMapValue) IsCumulative() bool {
	return true
}

// -- uint8UintMapValue.
type uint8UintMapValue struct {
	value     *map[uint8]uint
	separator string
}

var _ RepeatableFlag = (*uint8UintMapValue)(nil)
var _ Value = (*uint8UintMapValue)(nil)
var _ Getter = (*uint8UintMapValue)(nil)

func newUint8UintMapValue(m *map[uint8]uint, sep *string) *uint8UintMapValue {
	s := &uint8UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8UintMapValue) Type() string { return "map[uint8]uint" }

func (v *uint8UintMapValue) IsCumulative() bool {
	return true
}

// -- uint16UintMapValue.
type uint16UintMapValue struct {
	value     *map[uint16]uint
	separator string
}

var _ RepeatableFlag = (*uint16UintMapValue)(nil)
var _ Value = (*uint16UintMapValue)(nil)
var _ Getter = (*uint16UintMapValue)(nil)

func newUint16UintMapValue(m *map[uint16]uint, sep *string) *uint16UintMapValue {
	s := &uint16UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16UintMapValue) Type() string { return "map[uint16]uint" }

func (v *uint16UintMapValue) IsCumulative() bool {
	return true
}

// -- uint32UintMapValue.
type uint32UintMapValue struct {
	value     *map[uint32]uint
	separator string
}

var _ RepeatableFlag = (*uint32UintMapValue)(nil)
var _ Value = (*uint32UintMapValue)(nil)
var _ Getter = (*uint32UintMapValue)(nil)

func newUint32UintMapValue(m *map[uint32]uint, sep *string) *uint32UintMapValue {
	s := &uint32UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32UintMapValue) Type() string { return "map[uint32]uint" }

func (v *uint32UintMapValue) IsCumulative() bool {
	return true
}

// -- uint64UintMapValue.
type uint64UintMapValue struct {
	value     *map[uint64]uint
	separator string
}

var _ RepeatableFlag = (*uint64UintMapValue)(nil)
var _ Value = (*uint64UintMapValue)(nil)
var _ Getter = (*uint64UintMapValue)(nil)

func newUint64UintMapValue(m *map[uint64]uint, sep *string) *uint64UintMapValue {
	s := &uint64UintMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64UintMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := (uint)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64UintMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64UintMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64UintMapValue) Type() string { return "map[uint64]uint" }

func (v *uint64UintMapValue) IsCumulative() bool {
	return true
}

// -- uint8 Value.
type uint8Value struct {
	value *uint8
}

var _ Value = (*uint8Value)(nil)
var _ Getter = (*uint8Value)(nil)

func newUint8Value(p *uint8) *uint8Value {
	return &uint8Value{value: p}
}

func (v *uint8Value) Set(s string) error {

	parsed, err := strconv.ParseUint(s, 0, 8)
	if err == nil {

		*v.value = (uint8)(parsed)

		return nil
	}

	return err

}

func (v *uint8Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *uint8Value) String() string {
	if v != nil && v.value != nil {

		return strconv.FormatUint(uint64(*v.value), 10)
	}

	return ""
}

func (v *uint8Value) Type() string { return "uint8" }

// -- uint8Slice Value

type uint8SliceValue struct {
	value     *[]uint8
	changed   bool
	separator string
}

var _ RepeatableFlag = (*uint8SliceValue)(nil)
var _ Value = (*uint8SliceValue)(nil)
var _ Getter = (*uint8SliceValue)(nil)

func newUint8SliceValue(slice *[]uint8, sep *string) *uint8SliceValue {
	s := &uint8SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]uint8, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		out[i] = (uint8)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *uint8SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]uint8)(nil)
}

func (v *uint8SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint8Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint8SliceValue) Type() string { return "uint8Slice" }

func (v *uint8SliceValue) IsCumulative() bool {
	return true
}

// -- stringUint8MapValue.
type stringUint8MapValue struct {
	value     *map[string]uint8
	separator string
}

var _ RepeatableFlag = (*stringUint8MapValue)(nil)
var _ Value = (*stringUint8MapValue)(nil)
var _ Getter = (*stringUint8MapValue)(nil)

func newStringUint8MapValue(m *map[string]uint8, sep *string) *stringUint8MapValue {
	s := &stringUint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringUint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringUint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringUint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringUint8MapValue) Type() string { return "map[string]uint8" }

func (v *stringUint8MapValue) IsCumulative() bool {
	return true
}

// -- intUint8MapValue.
type intUint8MapValue struct {
	value     *map[int]uint8
	separator string
}

var _ RepeatableFlag = (*intUint8MapValue)(nil)
var _ Value = (*intUint8MapValue)(nil)
var _ Getter = (*intUint8MapValue)(nil)

func newIntUint8MapValue(m *map[int]uint8, sep *string) *intUint8MapValue {
	s := &intUint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intUint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intUint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intUint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intUint8MapValue) Type() string { return "map[int]uint8" }

func (v *intUint8MapValue) IsCumulative() bool {
	return true
}

// -- int8Uint8MapValue.
type int8Uint8MapValue struct {
	value     *map[int8]uint8
	separator string
}

var _ RepeatableFlag = (*int8Uint8MapValue)(nil)
var _ Value = (*int8Uint8MapValue)(nil)
var _ Getter = (*int8Uint8MapValue)(nil)

func newInt8Uint8MapValue(m *map[int8]uint8, sep *string) *int8Uint8MapValue {
	s := &int8Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Uint8MapValue) Type() string { return "map[int8]uint8" }

func (v *int8Uint8MapValue) IsCumulative() bool {
	return true
}

// -- int16Uint8MapValue.
type int16Uint8MapValue struct {
	value     *map[int16]uint8
	separator string
}

var _ RepeatableFlag = (*int16Uint8MapValue)(nil)
var _ Value = (*int16Uint8MapValue)(nil)
var _ Getter = (*int16Uint8MapValue)(nil)

func newInt16Uint8MapValue(m *map[int16]uint8, sep *string) *int16Uint8MapValue {
	s := &int16Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Uint8MapValue) Type() string { return "map[int16]uint8" }

func (v *int16Uint8MapValue) IsCumulative() bool {
	return true
}

// -- int32Uint8MapValue.
type int32Uint8MapValue struct {
	value     *map[int32]uint8
	separator string
}

var _ RepeatableFlag = (*int32Uint8MapValue)(nil)
var _ Value = (*int32Uint8MapValue)(nil)
var _ Getter = (*int32Uint8MapValue)(nil)

func newInt32Uint8MapValue(m *map[int32]uint8, sep *string) *int32Uint8MapValue {
	s := &int32Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Uint8MapValue) Type() string { return "map[int32]uint8" }

func (v *int32Uint8MapValue) IsCumulative() bool {
	return true
}

// -- int64Uint8MapValue.
type int64Uint8MapValue struct {
	value     *map[int64]uint8
	separator string
}

var _ RepeatableFlag = (*int64Uint8MapValue)(nil)
var _ Value = (*int64Uint8MapValue)(nil)
var _ Getter = (*int64Uint8MapValue)(nil)

func newInt64Uint8MapValue(m *map[int64]uint8, sep *string) *int64Uint8MapValue {
	s := &int64Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Uint8MapValue) Type() string { return "map[int64]uint8" }

func (v *int64Uint8MapValue) IsCumulative() bool {
	return true
}

// -- uintUint8MapValue.
type uintUint8MapValue struct {
	value     *map[uint]uint8
	separator string
}

var _ RepeatableFlag = (*uintUint8MapValue)(nil)
var _ Value = (*uintUint8MapValue)(nil)
var _ Getter = (*uintUint8MapValue)(nil)

func newUintUint8MapValue(m *map[uint]uint8, sep *string) *uintUint8MapValue {
	s := &uintUint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintUint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintUint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintUint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintUint8MapValue) Type() string { return "map[uint]uint8" }

func (v *uintUint8MapValue) IsCumulative() bool {
	return true
}

// -- uint8Uint8MapValue.
type uint8Uint8MapValue struct {
	value     *map[uint8]uint8
	separator string
}

var _ RepeatableFlag = (*uint8Uint8MapValue)(nil)
var _ Value = (*uint8Uint8MapValue)(nil)
var _ Getter = (*uint8Uint8MapValue)(nil)

func newUint8Uint8MapValue(m *map[uint8]uint8, sep *string) *uint8Uint8MapValue {
	s := &uint8Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Uint8MapValue) Type() string { return "map[uint8]uint8" }

func (v *uint8Uint8MapValue) IsCumulative() bool {
	return true
}

// -- uint16Uint8MapValue.
type uint16Uint8MapValue struct {
	value     *map[uint16]uint8
	separator string
}

var _ RepeatableFlag = (*uint16Uint8MapValue)(nil)
var _ Value = (*uint16Uint8MapValue)(nil)
var _ Getter = (*uint16Uint8MapValue)(nil)

func newUint16Uint8MapValue(m *map[uint16]uint8, sep *string) *uint16Uint8MapValue {
	s := &uint16Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Uint8MapValue) Type() string { return "map[uint16]uint8" }

func (v *uint16Uint8MapValue) IsCumulative() bool {
	return true
}

// -- uint32Uint8MapValue.
type uint32Uint8MapValue struct {
	value     *map[uint32]uint8
	separator string
}

var _ RepeatableFlag = (*uint32Uint8MapValue)(nil)
var _ Value = (*uint32Uint8MapValue)(nil)
var _ Getter = (*uint32Uint8MapValue)(nil)

func newUint32Uint8MapValue(m *map[uint32]uint8, sep *string) *uint32Uint8MapValue {
	s := &uint32Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Uint8MapValue) Type() string { return "map[uint32]uint8" }

func (v *uint32Uint8MapValue) IsCumulative() bool {
	return true
}

// -- uint64Uint8MapValue.
type uint64Uint8MapValue struct {
	value     *map[uint64]uint8
	separator string
}

var _ RepeatableFlag = (*uint64Uint8MapValue)(nil)
var _ Value = (*uint64Uint8MapValue)(nil)
var _ Getter = (*uint64Uint8MapValue)(nil)

func newUint64Uint8MapValue(m *map[uint64]uint8, sep *string) *uint64Uint8MapValue {
	s := &uint64Uint8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Uint8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		val := (uint8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Uint8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Uint8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Uint8MapValue) Type() string { return "map[uint64]uint8" }

func (v *uint64Uint8MapValue) IsCumulative() bool {
	return true
}

// -- uint16 Value.
type uint16Value struct {
	value *uint16
}

var _ Value = (*uint16Value)(nil)
var _ Getter = (*uint16Value)(nil)

func newUint16Value(p *uint16) *uint16Value {
	return &uint16Value{value: p}
}

func (v *uint16Value) Set(s string) error {

	parsed, err := strconv.ParseUint(s, 0, 16)
	if err == nil {

		*v.value = (uint16)(parsed)

		return nil
	}

	return err

}

func (v *uint16Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *uint16Value) String() string {
	if v != nil && v.value != nil {

		return strconv.FormatUint(uint64(*v.value), 10)
	}

	return ""
}

func (v *uint16Value) Type() string { return "uint16" }

// -- uint16Slice Value

type uint16SliceValue struct {
	value     *[]uint16
	changed   bool
	separator string
}

var _ RepeatableFlag = (*uint16SliceValue)(nil)
var _ Value = (*uint16SliceValue)(nil)
var _ Getter = (*uint16SliceValue)(nil)

func newUint16SliceValue(slice *[]uint16, sep *string) *uint16SliceValue {
	s := &uint16SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]uint16, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		out[i] = (uint16)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *uint16SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]uint16)(nil)
}

func (v *uint16SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint16Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint16SliceValue) Type() string { return "uint16Slice" }

func (v *uint16SliceValue) IsCumulative() bool {
	return true
}

// -- stringUint16MapValue.
type stringUint16MapValue struct {
	value     *map[string]uint16
	separator string
}

var _ RepeatableFlag = (*stringUint16MapValue)(nil)
var _ Value = (*stringUint16MapValue)(nil)
var _ Getter = (*stringUint16MapValue)(nil)

func newStringUint16MapValue(m *map[string]uint16, sep *string) *stringUint16MapValue {
	s := &stringUint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringUint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringUint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringUint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringUint16MapValue) Type() string { return "map[string]uint16" }

func (v *stringUint16MapValue) IsCumulative() bool {
	return true
}

// -- intUint16MapValue.
type intUint16MapValue struct {
	value     *map[int]uint16
	separator string
}

var _ RepeatableFlag = (*intUint16MapValue)(nil)
var _ Value = (*intUint16MapValue)(nil)
var _ Getter = (*intUint16MapValue)(nil)

func newIntUint16MapValue(m *map[int]uint16, sep *string) *intUint16MapValue {
	s := &intUint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intUint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intUint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intUint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intUint16MapValue) Type() string { return "map[int]uint16" }

func (v *intUint16MapValue) IsCumulative() bool {
	return true
}

// -- int8Uint16MapValue.
type int8Uint16MapValue struct {
	value     *map[int8]uint16
	separator string
}

var _ RepeatableFlag = (*int8Uint16MapValue)(nil)
var _ Value = (*int8Uint16MapValue)(nil)
var _ Getter = (*int8Uint16MapValue)(nil)

func newInt8Uint16MapValue(m *map[int8]uint16, sep *string) *int8Uint16MapValue {
	s := &int8Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Uint16MapValue) Type() string { return "map[int8]uint16" }

func (v *int8Uint16MapValue) IsCumulative() bool {
	return true
}

// -- int16Uint16MapValue.
type int16Uint16MapValue struct {
	value     *map[int16]uint16
	separator string
}

var _ RepeatableFlag = (*int16Uint16MapValue)(nil)
var _ Value = (*int16Uint16MapValue)(nil)
var _ Getter = (*int16Uint16MapValue)(nil)

func newInt16Uint16MapValue(m *map[int16]uint16, sep *string) *int16Uint16MapValue {
	s := &int16Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Uint16MapValue) Type() string { return "map[int16]uint16" }

func (v *int16Uint16MapValue) IsCumulative() bool {
	return true
}

// -- int32Uint16MapValue.
type int32Uint16MapValue struct {
	value     *map[int32]uint16
	separator string
}

var _ RepeatableFlag = (*int32Uint16MapValue)(nil)
var _ Value = (*int32Uint16MapValue)(nil)
var _ Getter = (*int32Uint16MapValue)(nil)

func newInt32Uint16MapValue(m *map[int32]uint16, sep *string) *int32Uint16MapValue {
	s := &int32Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Uint16MapValue) Type() string { return "map[int32]uint16" }

func (v *int32Uint16MapValue) IsCumulative() bool {
	return true
}

// -- int64Uint16MapValue.
type int64Uint16MapValue struct {
	value     *map[int64]uint16
	separator string
}

var _ RepeatableFlag = (*int64Uint16MapValue)(nil)
var _ Value = (*int64Uint16MapValue)(nil)
var _ Getter = (*int64Uint16MapValue)(nil)

func newInt64Uint16MapValue(m *map[int64]uint16, sep *string) *int64Uint16MapValue {
	s := &int64Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Uint16MapValue) Type() string { return "map[int64]uint16" }

func (v *int64Uint16MapValue) IsCumulative() bool {
	return true
}

// -- uintUint16MapValue.
type uintUint16MapValue struct {
	value     *map[uint]uint16
	separator string
}

var _ RepeatableFlag = (*uintUint16MapValue)(nil)
var _ Value = (*uintUint16MapValue)(nil)
var _ Getter = (*uintUint16MapValue)(nil)

func newUintUint16MapValue(m *map[uint]uint16, sep *string) *uintUint16MapValue {
	s := &uintUint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintUint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintUint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintUint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintUint16MapValue) Type() string { return "map[uint]uint16" }

func (v *uintUint16MapValue) IsCumulative() bool {
	return true
}

// -- uint8Uint16MapValue.
type uint8Uint16MapValue struct {
	value     *map[uint8]uint16
	separator string
}

var _ RepeatableFlag = (*uint8Uint16MapValue)(nil)
var _ Value = (*uint8Uint16MapValue)(nil)
var _ Getter = (*uint8Uint16MapValue)(nil)

func newUint8Uint16MapValue(m *map[uint8]uint16, sep *string) *uint8Uint16MapValue {
	s := &uint8Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Uint16MapValue) Type() string { return "map[uint8]uint16" }

func (v *uint8Uint16MapValue) IsCumulative() bool {
	return true
}

// -- uint16Uint16MapValue.
type uint16Uint16MapValue struct {
	value     *map[uint16]uint16
	separator string
}

var _ RepeatableFlag = (*uint16Uint16MapValue)(nil)
var _ Value = (*uint16Uint16MapValue)(nil)
var _ Getter = (*uint16Uint16MapValue)(nil)

func newUint16Uint16MapValue(m *map[uint16]uint16, sep *string) *uint16Uint16MapValue {
	s := &uint16Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Uint16MapValue) Type() string { return "map[uint16]uint16" }

func (v *uint16Uint16MapValue) IsCumulative() bool {
	return true
}

// -- uint32Uint16MapValue.
type uint32Uint16MapValue struct {
	value     *map[uint32]uint16
	separator string
}

var _ RepeatableFlag = (*uint32Uint16MapValue)(nil)
var _ Value = (*uint32Uint16MapValue)(nil)
var _ Getter = (*uint32Uint16MapValue)(nil)

func newUint32Uint16MapValue(m *map[uint32]uint16, sep *string) *uint32Uint16MapValue {
	s := &uint32Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Uint16MapValue) Type() string { return "map[uint32]uint16" }

func (v *uint32Uint16MapValue) IsCumulative() bool {
	return true
}

// -- uint64Uint16MapValue.
type uint64Uint16MapValue struct {
	value     *map[uint64]uint16
	separator string
}

var _ RepeatableFlag = (*uint64Uint16MapValue)(nil)
var _ Value = (*uint64Uint16MapValue)(nil)
var _ Getter = (*uint64Uint16MapValue)(nil)

func newUint64Uint16MapValue(m *map[uint64]uint16, sep *string) *uint64Uint16MapValue {
	s := &uint64Uint16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Uint16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		val := (uint16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Uint16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Uint16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Uint16MapValue) Type() string { return "map[uint64]uint16" }

func (v *uint64Uint16MapValue) IsCumulative() bool {
	return true
}

// -- uint32 Value.
type uint32Value struct {
	value *uint32
}

var _ Value = (*uint32Value)(nil)
var _ Getter = (*uint32Value)(nil)

func newUint32Value(p *uint32) *uint32Value {
	return &uint32Value{value: p}
}

func (v *uint32Value) Set(s string) error {

	parsed, err := strconv.ParseUint(s, 0, 32)
	if err == nil {

		*v.value = (uint32)(parsed)

		return nil
	}

	return err

}

func (v *uint32Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *uint32Value) String() string {
	if v != nil && v.value != nil {

		return strconv.FormatUint(uint64(*v.value), 10)
	}

	return ""
}

func (v *uint32Value) Type() string { return "uint32" }

// -- uint32Slice Value

type uint32SliceValue struct {
	value     *[]uint32
	changed   bool
	separator string
}

var _ RepeatableFlag = (*uint32SliceValue)(nil)
var _ Value = (*uint32SliceValue)(nil)
var _ Getter = (*uint32SliceValue)(nil)

func newUint32SliceValue(slice *[]uint32, sep *string) *uint32SliceValue {
	s := &uint32SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]uint32, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		out[i] = (uint32)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *uint32SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]uint32)(nil)
}

func (v *uint32SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint32Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint32SliceValue) Type() string { return "uint32Slice" }

func (v *uint32SliceValue) IsCumulative() bool {
	return true
}

// -- stringUint32MapValue.
type stringUint32MapValue struct {
	value     *map[string]uint32
	separator string
}

var _ RepeatableFlag = (*stringUint32MapValue)(nil)
var _ Value = (*stringUint32MapValue)(nil)
var _ Getter = (*stringUint32MapValue)(nil)

func newStringUint32MapValue(m *map[string]uint32, sep *string) *stringUint32MapValue {
	s := &stringUint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringUint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringUint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringUint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringUint32MapValue) Type() string { return "map[string]uint32" }

func (v *stringUint32MapValue) IsCumulative() bool {
	return true
}

// -- intUint32MapValue.
type intUint32MapValue struct {
	value     *map[int]uint32
	separator string
}

var _ RepeatableFlag = (*intUint32MapValue)(nil)
var _ Value = (*intUint32MapValue)(nil)
var _ Getter = (*intUint32MapValue)(nil)

func newIntUint32MapValue(m *map[int]uint32, sep *string) *intUint32MapValue {
	s := &intUint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intUint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intUint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intUint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intUint32MapValue) Type() string { return "map[int]uint32" }

func (v *intUint32MapValue) IsCumulative() bool {
	return true
}

// -- int8Uint32MapValue.
type int8Uint32MapValue struct {
	value     *map[int8]uint32
	separator string
}

var _ RepeatableFlag = (*int8Uint32MapValue)(nil)
var _ Value = (*int8Uint32MapValue)(nil)
var _ Getter = (*int8Uint32MapValue)(nil)

func newInt8Uint32MapValue(m *map[int8]uint32, sep *string) *int8Uint32MapValue {
	s := &int8Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Uint32MapValue) Type() string { return "map[int8]uint32" }

func (v *int8Uint32MapValue) IsCumulative() bool {
	return true
}

// -- int16Uint32MapValue.
type int16Uint32MapValue struct {
	value     *map[int16]uint32
	separator string
}

var _ RepeatableFlag = (*int16Uint32MapValue)(nil)
var _ Value = (*int16Uint32MapValue)(nil)
var _ Getter = (*int16Uint32MapValue)(nil)

func newInt16Uint32MapValue(m *map[int16]uint32, sep *string) *int16Uint32MapValue {
	s := &int16Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Uint32MapValue) Type() string { return "map[int16]uint32" }

func (v *int16Uint32MapValue) IsCumulative() bool {
	return true
}

// -- int32Uint32MapValue.
type int32Uint32MapValue struct {
	value     *map[int32]uint32
	separator string
}

var _ RepeatableFlag = (*int32Uint32MapValue)(nil)
var _ Value = (*int32Uint32MapValue)(nil)
var _ Getter = (*int32Uint32MapValue)(nil)

func newInt32Uint32MapValue(m *map[int32]uint32, sep *string) *int32Uint32MapValue {
	s := &int32Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Uint32MapValue) Type() string { return "map[int32]uint32" }

func (v *int32Uint32MapValue) IsCumulative() bool {
	return true
}

// -- int64Uint32MapValue.
type int64Uint32MapValue struct {
	value     *map[int64]uint32
	separator string
}

var _ RepeatableFlag = (*int64Uint32MapValue)(nil)
var _ Value = (*int64Uint32MapValue)(nil)
var _ Getter = (*int64Uint32MapValue)(nil)

func newInt64Uint32MapValue(m *map[int64]uint32, sep *string) *int64Uint32MapValue {
	s := &int64Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Uint32MapValue) Type() string { return "map[int64]uint32" }

func (v *int64Uint32MapValue) IsCumulative() bool {
	return true
}

// -- uintUint32MapValue.
type uintUint32MapValue struct {
	value     *map[uint]uint32
	separator string
}

var _ RepeatableFlag = (*uintUint32MapValue)(nil)
var _ Value = (*uintUint32MapValue)(nil)
var _ Getter = (*uintUint32MapValue)(nil)

func newUintUint32MapValue(m *map[uint]uint32, sep *string) *uintUint32MapValue {
	s := &uintUint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintUint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintUint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintUint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintUint32MapValue) Type() string { return "map[uint]uint32" }

func (v *uintUint32MapValue) IsCumulative() bool {
	return true
}

// -- uint8Uint32MapValue.
type uint8Uint32MapValue struct {
	value     *map[uint8]uint32
	separator string
}

var _ RepeatableFlag = (*uint8Uint32MapValue)(nil)
var _ Value = (*uint8Uint32MapValue)(nil)
var _ Getter = (*uint8Uint32MapValue)(nil)

func newUint8Uint32MapValue(m *map[uint8]uint32, sep *string) *uint8Uint32MapValue {
	s := &uint8Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Uint32MapValue) Type() string { return "map[uint8]uint32" }

func (v *uint8Uint32MapValue) IsCumulative() bool {
	return true
}

// -- uint16Uint32MapValue.
type uint16Uint32MapValue struct {
	value     *map[uint16]uint32
	separator string
}

var _ RepeatableFlag = (*uint16Uint32MapValue)(nil)
var _ Value = (*uint16Uint32MapValue)(nil)
var _ Getter = (*uint16Uint32MapValue)(nil)

func newUint16Uint32MapValue(m *map[uint16]uint32, sep *string) *uint16Uint32MapValue {
	s := &uint16Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Uint32MapValue) Type() string { return "map[uint16]uint32" }

func (v *uint16Uint32MapValue) IsCumulative() bool {
	return true
}

// -- uint32Uint32MapValue.
type uint32Uint32MapValue struct {
	value     *map[uint32]uint32
	separator string
}

var _ RepeatableFlag = (*uint32Uint32MapValue)(nil)
var _ Value = (*uint32Uint32MapValue)(nil)
var _ Getter = (*uint32Uint32MapValue)(nil)

func newUint32Uint32MapValue(m *map[uint32]uint32, sep *string) *uint32Uint32MapValue {
	s := &uint32Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Uint32MapValue) Type() string { return "map[uint32]uint32" }

func (v *uint32Uint32MapValue) IsCumulative() bool {
	return true
}

// -- uint64Uint32MapValue.
type uint64Uint32MapValue struct {
	value     *map[uint64]uint32
	separator string
}

var _ RepeatableFlag = (*uint64Uint32MapValue)(nil)
var _ Value = (*uint64Uint32MapValue)(nil)
var _ Getter = (*uint64Uint32MapValue)(nil)

func newUint64Uint32MapValue(m *map[uint64]uint32, sep *string) *uint64Uint32MapValue {
	s := &uint64Uint32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Uint32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		val := (uint32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Uint32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Uint32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Uint32MapValue) Type() string { return "map[uint64]uint32" }

func (v *uint64Uint32MapValue) IsCumulative() bool {
	return true
}

// -- uint64 Value.
type uint64Value struct {
	value *uint64
}

var _ Value = (*uint64Value)(nil)
var _ Getter = (*uint64Value)(nil)

func newUint64Value(p *uint64) *uint64Value {
	return &uint64Value{value: p}
}

func (v *uint64Value) Set(s string) error {

	parsed, err := strconv.ParseUint(s, 0, 64)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *uint64Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *uint64Value) String() string {
	if v != nil && v.value != nil {

		return strconv.FormatUint(*v.value, 10)
	}

	return ""
}

func (v *uint64Value) Type() string { return "uint64" }

// -- uint64Slice Value

type uint64SliceValue struct {
	value     *[]uint64
	changed   bool
	separator string
}

var _ RepeatableFlag = (*uint64SliceValue)(nil)
var _ Value = (*uint64SliceValue)(nil)
var _ Getter = (*uint64SliceValue)(nil)

func newUint64SliceValue(slice *[]uint64, sep *string) *uint64SliceValue {
	s := &uint64SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]uint64, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *uint64SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]uint64)(nil)
}

func (v *uint64SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newUint64Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *uint64SliceValue) Type() string { return "uint64Slice" }

func (v *uint64SliceValue) IsCumulative() bool {
	return true
}

// -- stringUint64MapValue.
type stringUint64MapValue struct {
	value     *map[string]uint64
	separator string
}

var _ RepeatableFlag = (*stringUint64MapValue)(nil)
var _ Value = (*stringUint64MapValue)(nil)
var _ Getter = (*stringUint64MapValue)(nil)

func newStringUint64MapValue(m *map[string]uint64, sep *string) *stringUint64MapValue {
	s := &stringUint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringUint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringUint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringUint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringUint64MapValue) Type() string { return "map[string]uint64" }

func (v *stringUint64MapValue) IsCumulative() bool {
	return true
}

// -- intUint64MapValue.
type intUint64MapValue struct {
	value     *map[int]uint64
	separator string
}

var _ RepeatableFlag = (*intUint64MapValue)(nil)
var _ Value = (*intUint64MapValue)(nil)
var _ Getter = (*intUint64MapValue)(nil)

func newIntUint64MapValue(m *map[int]uint64, sep *string) *intUint64MapValue {
	s := &intUint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intUint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intUint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intUint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intUint64MapValue) Type() string { return "map[int]uint64" }

func (v *intUint64MapValue) IsCumulative() bool {
	return true
}

// -- int8Uint64MapValue.
type int8Uint64MapValue struct {
	value     *map[int8]uint64
	separator string
}

var _ RepeatableFlag = (*int8Uint64MapValue)(nil)
var _ Value = (*int8Uint64MapValue)(nil)
var _ Getter = (*int8Uint64MapValue)(nil)

func newInt8Uint64MapValue(m *map[int8]uint64, sep *string) *int8Uint64MapValue {
	s := &int8Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Uint64MapValue) Type() string { return "map[int8]uint64" }

func (v *int8Uint64MapValue) IsCumulative() bool {
	return true
}

// -- int16Uint64MapValue.
type int16Uint64MapValue struct {
	value     *map[int16]uint64
	separator string
}

var _ RepeatableFlag = (*int16Uint64MapValue)(nil)
var _ Value = (*int16Uint64MapValue)(nil)
var _ Getter = (*int16Uint64MapValue)(nil)

func newInt16Uint64MapValue(m *map[int16]uint64, sep *string) *int16Uint64MapValue {
	s := &int16Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Uint64MapValue) Type() string { return "map[int16]uint64" }

func (v *int16Uint64MapValue) IsCumulative() bool {
	return true
}

// -- int32Uint64MapValue.
type int32Uint64MapValue struct {
	value     *map[int32]uint64
	separator string
}

var _ RepeatableFlag = (*int32Uint64MapValue)(nil)
var _ Value = (*int32Uint64MapValue)(nil)
var _ Getter = (*int32Uint64MapValue)(nil)

func newInt32Uint64MapValue(m *map[int32]uint64, sep *string) *int32Uint64MapValue {
	s := &int32Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Uint64MapValue) Type() string { return "map[int32]uint64" }

func (v *int32Uint64MapValue) IsCumulative() bool {
	return true
}

// -- int64Uint64MapValue.
type int64Uint64MapValue struct {
	value     *map[int64]uint64
	separator string
}

var _ RepeatableFlag = (*int64Uint64MapValue)(nil)
var _ Value = (*int64Uint64MapValue)(nil)
var _ Getter = (*int64Uint64MapValue)(nil)

func newInt64Uint64MapValue(m *map[int64]uint64, sep *string) *int64Uint64MapValue {
	s := &int64Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Uint64MapValue) Type() string { return "map[int64]uint64" }

func (v *int64Uint64MapValue) IsCumulative() bool {
	return true
}

// -- uintUint64MapValue.
type uintUint64MapValue struct {
	value     *map[uint]uint64
	separator string
}

var _ RepeatableFlag = (*uintUint64MapValue)(nil)
var _ Value = (*uintUint64MapValue)(nil)
var _ Getter = (*uintUint64MapValue)(nil)

func newUintUint64MapValue(m *map[uint]uint64, sep *string) *uintUint64MapValue {
	s := &uintUint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintUint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintUint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintUint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintUint64MapValue) Type() string { return "map[uint]uint64" }

func (v *uintUint64MapValue) IsCumulative() bool {
	return true
}

// -- uint8Uint64MapValue.
type uint8Uint64MapValue struct {
	value     *map[uint8]uint64
	separator string
}

var _ RepeatableFlag = (*uint8Uint64MapValue)(nil)
var _ Value = (*uint8Uint64MapValue)(nil)
var _ Getter = (*uint8Uint64MapValue)(nil)

func newUint8Uint64MapValue(m *map[uint8]uint64, sep *string) *uint8Uint64MapValue {
	s := &uint8Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Uint64MapValue) Type() string { return "map[uint8]uint64" }

func (v *uint8Uint64MapValue) IsCumulative() bool {
	return true
}

// -- uint16Uint64MapValue.
type uint16Uint64MapValue struct {
	value     *map[uint16]uint64
	separator string
}

var _ RepeatableFlag = (*uint16Uint64MapValue)(nil)
var _ Value = (*uint16Uint64MapValue)(nil)
var _ Getter = (*uint16Uint64MapValue)(nil)

func newUint16Uint64MapValue(m *map[uint16]uint64, sep *string) *uint16Uint64MapValue {
	s := &uint16Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Uint64MapValue) Type() string { return "map[uint16]uint64" }

func (v *uint16Uint64MapValue) IsCumulative() bool {
	return true
}

// -- uint32Uint64MapValue.
type uint32Uint64MapValue struct {
	value     *map[uint32]uint64
	separator string
}

var _ RepeatableFlag = (*uint32Uint64MapValue)(nil)
var _ Value = (*uint32Uint64MapValue)(nil)
var _ Getter = (*uint32Uint64MapValue)(nil)

func newUint32Uint64MapValue(m *map[uint32]uint64, sep *string) *uint32Uint64MapValue {
	s := &uint32Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Uint64MapValue) Type() string { return "map[uint32]uint64" }

func (v *uint32Uint64MapValue) IsCumulative() bool {
	return true
}

// -- uint64Uint64MapValue.
type uint64Uint64MapValue struct {
	value     *map[uint64]uint64
	separator string
}

var _ RepeatableFlag = (*uint64Uint64MapValue)(nil)
var _ Value = (*uint64Uint64MapValue)(nil)
var _ Getter = (*uint64Uint64MapValue)(nil)

func newUint64Uint64MapValue(m *map[uint64]uint64, sep *string) *uint64Uint64MapValue {
	s := &uint64Uint64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Uint64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Uint64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Uint64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Uint64MapValue) Type() string { return "map[uint64]uint64" }

func (v *uint64Uint64MapValue) IsCumulative() bool {
	return true
}

// -- int Value.
type intValue struct {
	value *int
}

var _ Value = (*intValue)(nil)
var _ Getter = (*intValue)(nil)

func newIntValue(p *int) *intValue {
	return &intValue{value: p}
}

func (v *intValue) Set(s string) error {

	parsed, err := strconv.ParseInt(s, 0, 64)
	if err == nil {

		*v.value = (int)(parsed)

		return nil
	}

	return err

}

func (v *intValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *intValue) String() string {
	if v != nil && v.value != nil {

		return strconv.Itoa(*v.value)
	}

	return ""
}

func (v *intValue) Type() string { return "int" }

// -- intSlice Value

type intSliceValue struct {
	value     *[]int
	changed   bool
	separator string
}

var _ RepeatableFlag = (*intSliceValue)(nil)
var _ Value = (*intSliceValue)(nil)
var _ Getter = (*intSliceValue)(nil)

func newIntSliceValue(slice *[]int, sep *string) *intSliceValue {
	s := &intSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]int, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		out[i] = (int)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *intSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]int)(nil)
}

func (v *intSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newIntValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *intSliceValue) Type() string { return "intSlice" }

func (v *intSliceValue) IsCumulative() bool {
	return true
}

// -- stringIntMapValue.
type stringIntMapValue struct {
	value     *map[string]int
	separator string
}

var _ RepeatableFlag = (*stringIntMapValue)(nil)
var _ Value = (*stringIntMapValue)(nil)
var _ Getter = (*stringIntMapValue)(nil)

func newStringIntMapValue(m *map[string]int, sep *string) *stringIntMapValue {
	s := &stringIntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringIntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringIntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringIntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringIntMapValue) Type() string { return "map[string]int" }

func (v *stringIntMapValue) IsCumulative() bool {
	return true
}

// -- intIntMapValue.
type intIntMapValue struct {
	value     *map[int]int
	separator string
}

var _ RepeatableFlag = (*intIntMapValue)(nil)
var _ Value = (*intIntMapValue)(nil)
var _ Getter = (*intIntMapValue)(nil)

func newIntIntMapValue(m *map[int]int, sep *string) *intIntMapValue {
	s := &intIntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intIntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intIntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intIntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intIntMapValue) Type() string { return "map[int]int" }

func (v *intIntMapValue) IsCumulative() bool {
	return true
}

// -- int8IntMapValue.
type int8IntMapValue struct {
	value     *map[int8]int
	separator string
}

var _ RepeatableFlag = (*int8IntMapValue)(nil)
var _ Value = (*int8IntMapValue)(nil)
var _ Getter = (*int8IntMapValue)(nil)

func newInt8IntMapValue(m *map[int8]int, sep *string) *int8IntMapValue {
	s := &int8IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8IntMapValue) Type() string { return "map[int8]int" }

func (v *int8IntMapValue) IsCumulative() bool {
	return true
}

// -- int16IntMapValue.
type int16IntMapValue struct {
	value     *map[int16]int
	separator string
}

var _ RepeatableFlag = (*int16IntMapValue)(nil)
var _ Value = (*int16IntMapValue)(nil)
var _ Getter = (*int16IntMapValue)(nil)

func newInt16IntMapValue(m *map[int16]int, sep *string) *int16IntMapValue {
	s := &int16IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16IntMapValue) Type() string { return "map[int16]int" }

func (v *int16IntMapValue) IsCumulative() bool {
	return true
}

// -- int32IntMapValue.
type int32IntMapValue struct {
	value     *map[int32]int
	separator string
}

var _ RepeatableFlag = (*int32IntMapValue)(nil)
var _ Value = (*int32IntMapValue)(nil)
var _ Getter = (*int32IntMapValue)(nil)

func newInt32IntMapValue(m *map[int32]int, sep *string) *int32IntMapValue {
	s := &int32IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32IntMapValue) Type() string { return "map[int32]int" }

func (v *int32IntMapValue) IsCumulative() bool {
	return true
}

// -- int64IntMapValue.
type int64IntMapValue struct {
	value     *map[int64]int
	separator string
}

var _ RepeatableFlag = (*int64IntMapValue)(nil)
var _ Value = (*int64IntMapValue)(nil)
var _ Getter = (*int64IntMapValue)(nil)

func newInt64IntMapValue(m *map[int64]int, sep *string) *int64IntMapValue {
	s := &int64IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64IntMapValue) Type() string { return "map[int64]int" }

func (v *int64IntMapValue) IsCumulative() bool {
	return true
}

// -- uintIntMapValue.
type uintIntMapValue struct {
	value     *map[uint]int
	separator string
}

var _ RepeatableFlag = (*uintIntMapValue)(nil)
var _ Value = (*uintIntMapValue)(nil)
var _ Getter = (*uintIntMapValue)(nil)

func newUintIntMapValue(m *map[uint]int, sep *string) *uintIntMapValue {
	s := &uintIntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintIntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintIntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintIntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintIntMapValue) Type() string { return "map[uint]int" }

func (v *uintIntMapValue) IsCumulative() bool {
	return true
}

// -- uint8IntMapValue.
type uint8IntMapValue struct {
	value     *map[uint8]int
	separator string
}

var _ RepeatableFlag = (*uint8IntMapValue)(nil)
var _ Value = (*uint8IntMapValue)(nil)
var _ Getter = (*uint8IntMapValue)(nil)

func newUint8IntMapValue(m *map[uint8]int, sep *string) *uint8IntMapValue {
	s := &uint8IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8IntMapValue) Type() string { return "map[uint8]int" }

func (v *uint8IntMapValue) IsCumulative() bool {
	return true
}

// -- uint16IntMapValue.
type uint16IntMapValue struct {
	value     *map[uint16]int
	separator string
}

var _ RepeatableFlag = (*uint16IntMapValue)(nil)
var _ Value = (*uint16IntMapValue)(nil)
var _ Getter = (*uint16IntMapValue)(nil)

func newUint16IntMapValue(m *map[uint16]int, sep *string) *uint16IntMapValue {
	s := &uint16IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16IntMapValue) Type() string { return "map[uint16]int" }

func (v *uint16IntMapValue) IsCumulative() bool {
	return true
}

// -- uint32IntMapValue.
type uint32IntMapValue struct {
	value     *map[uint32]int
	separator string
}

var _ RepeatableFlag = (*uint32IntMapValue)(nil)
var _ Value = (*uint32IntMapValue)(nil)
var _ Getter = (*uint32IntMapValue)(nil)

func newUint32IntMapValue(m *map[uint32]int, sep *string) *uint32IntMapValue {
	s := &uint32IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32IntMapValue) Type() string { return "map[uint32]int" }

func (v *uint32IntMapValue) IsCumulative() bool {
	return true
}

// -- uint64IntMapValue.
type uint64IntMapValue struct {
	value     *map[uint64]int
	separator string
}

var _ RepeatableFlag = (*uint64IntMapValue)(nil)
var _ Value = (*uint64IntMapValue)(nil)
var _ Getter = (*uint64IntMapValue)(nil)

func newUint64IntMapValue(m *map[uint64]int, sep *string) *uint64IntMapValue {
	s := &uint64IntMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64IntMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := (int)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64IntMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64IntMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64IntMapValue) Type() string { return "map[uint64]int" }

func (v *uint64IntMapValue) IsCumulative() bool {
	return true
}

// -- int8 Value.
type int8Value struct {
	value *int8
}

var _ Value = (*int8Value)(nil)
var _ Getter = (*int8Value)(nil)

func newInt8Value(p *int8) *int8Value {
	return &int8Value{value: p}
}

func (v *int8Value) Set(s string) error {

	parsed, err := strconv.ParseInt(s, 0, 8)
	if err == nil {

		*v.value = (int8)(parsed)

		return nil
	}

	return err

}

func (v *int8Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *int8Value) String() string {
	if v != nil && v.value != nil {

		return strconv.Itoa(int(*v.value))
	}

	return ""
}

func (v *int8Value) Type() string { return "int8" }

// -- int8Slice Value

type int8SliceValue struct {
	value     *[]int8
	changed   bool
	separator string
}

var _ RepeatableFlag = (*int8SliceValue)(nil)
var _ Value = (*int8SliceValue)(nil)
var _ Getter = (*int8SliceValue)(nil)

func newInt8SliceValue(slice *[]int8, sep *string) *int8SliceValue {
	s := &int8SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]int8, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		out[i] = (int8)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *int8SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]int8)(nil)
}

func (v *int8SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt8Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *int8SliceValue) Type() string { return "int8Slice" }

func (v *int8SliceValue) IsCumulative() bool {
	return true
}

// -- stringInt8MapValue.
type stringInt8MapValue struct {
	value     *map[string]int8
	separator string
}

var _ RepeatableFlag = (*stringInt8MapValue)(nil)
var _ Value = (*stringInt8MapValue)(nil)
var _ Getter = (*stringInt8MapValue)(nil)

func newStringInt8MapValue(m *map[string]int8, sep *string) *stringInt8MapValue {
	s := &stringInt8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringInt8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringInt8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringInt8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringInt8MapValue) Type() string { return "map[string]int8" }

func (v *stringInt8MapValue) IsCumulative() bool {
	return true
}

// -- intInt8MapValue.
type intInt8MapValue struct {
	value     *map[int]int8
	separator string
}

var _ RepeatableFlag = (*intInt8MapValue)(nil)
var _ Value = (*intInt8MapValue)(nil)
var _ Getter = (*intInt8MapValue)(nil)

func newIntInt8MapValue(m *map[int]int8, sep *string) *intInt8MapValue {
	s := &intInt8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intInt8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intInt8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intInt8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intInt8MapValue) Type() string { return "map[int]int8" }

func (v *intInt8MapValue) IsCumulative() bool {
	return true
}

// -- int8Int8MapValue.
type int8Int8MapValue struct {
	value     *map[int8]int8
	separator string
}

var _ RepeatableFlag = (*int8Int8MapValue)(nil)
var _ Value = (*int8Int8MapValue)(nil)
var _ Getter = (*int8Int8MapValue)(nil)

func newInt8Int8MapValue(m *map[int8]int8, sep *string) *int8Int8MapValue {
	s := &int8Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Int8MapValue) Type() string { return "map[int8]int8" }

func (v *int8Int8MapValue) IsCumulative() bool {
	return true
}

// -- int16Int8MapValue.
type int16Int8MapValue struct {
	value     *map[int16]int8
	separator string
}

var _ RepeatableFlag = (*int16Int8MapValue)(nil)
var _ Value = (*int16Int8MapValue)(nil)
var _ Getter = (*int16Int8MapValue)(nil)

func newInt16Int8MapValue(m *map[int16]int8, sep *string) *int16Int8MapValue {
	s := &int16Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Int8MapValue) Type() string { return "map[int16]int8" }

func (v *int16Int8MapValue) IsCumulative() bool {
	return true
}

// -- int32Int8MapValue.
type int32Int8MapValue struct {
	value     *map[int32]int8
	separator string
}

var _ RepeatableFlag = (*int32Int8MapValue)(nil)
var _ Value = (*int32Int8MapValue)(nil)
var _ Getter = (*int32Int8MapValue)(nil)

func newInt32Int8MapValue(m *map[int32]int8, sep *string) *int32Int8MapValue {
	s := &int32Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Int8MapValue) Type() string { return "map[int32]int8" }

func (v *int32Int8MapValue) IsCumulative() bool {
	return true
}

// -- int64Int8MapValue.
type int64Int8MapValue struct {
	value     *map[int64]int8
	separator string
}

var _ RepeatableFlag = (*int64Int8MapValue)(nil)
var _ Value = (*int64Int8MapValue)(nil)
var _ Getter = (*int64Int8MapValue)(nil)

func newInt64Int8MapValue(m *map[int64]int8, sep *string) *int64Int8MapValue {
	s := &int64Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Int8MapValue) Type() string { return "map[int64]int8" }

func (v *int64Int8MapValue) IsCumulative() bool {
	return true
}

// -- uintInt8MapValue.
type uintInt8MapValue struct {
	value     *map[uint]int8
	separator string
}

var _ RepeatableFlag = (*uintInt8MapValue)(nil)
var _ Value = (*uintInt8MapValue)(nil)
var _ Getter = (*uintInt8MapValue)(nil)

func newUintInt8MapValue(m *map[uint]int8, sep *string) *uintInt8MapValue {
	s := &uintInt8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintInt8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintInt8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintInt8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintInt8MapValue) Type() string { return "map[uint]int8" }

func (v *uintInt8MapValue) IsCumulative() bool {
	return true
}

// -- uint8Int8MapValue.
type uint8Int8MapValue struct {
	value     *map[uint8]int8
	separator string
}

var _ RepeatableFlag = (*uint8Int8MapValue)(nil)
var _ Value = (*uint8Int8MapValue)(nil)
var _ Getter = (*uint8Int8MapValue)(nil)

func newUint8Int8MapValue(m *map[uint8]int8, sep *string) *uint8Int8MapValue {
	s := &uint8Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Int8MapValue) Type() string { return "map[uint8]int8" }

func (v *uint8Int8MapValue) IsCumulative() bool {
	return true
}

// -- uint16Int8MapValue.
type uint16Int8MapValue struct {
	value     *map[uint16]int8
	separator string
}

var _ RepeatableFlag = (*uint16Int8MapValue)(nil)
var _ Value = (*uint16Int8MapValue)(nil)
var _ Getter = (*uint16Int8MapValue)(nil)

func newUint16Int8MapValue(m *map[uint16]int8, sep *string) *uint16Int8MapValue {
	s := &uint16Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Int8MapValue) Type() string { return "map[uint16]int8" }

func (v *uint16Int8MapValue) IsCumulative() bool {
	return true
}

// -- uint32Int8MapValue.
type uint32Int8MapValue struct {
	value     *map[uint32]int8
	separator string
}

var _ RepeatableFlag = (*uint32Int8MapValue)(nil)
var _ Value = (*uint32Int8MapValue)(nil)
var _ Getter = (*uint32Int8MapValue)(nil)

func newUint32Int8MapValue(m *map[uint32]int8, sep *string) *uint32Int8MapValue {
	s := &uint32Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Int8MapValue) Type() string { return "map[uint32]int8" }

func (v *uint32Int8MapValue) IsCumulative() bool {
	return true
}

// -- uint64Int8MapValue.
type uint64Int8MapValue struct {
	value     *map[uint64]int8
	separator string
}

var _ RepeatableFlag = (*uint64Int8MapValue)(nil)
var _ Value = (*uint64Int8MapValue)(nil)
var _ Getter = (*uint64Int8MapValue)(nil)

func newUint64Int8MapValue(m *map[uint64]int8, sep *string) *uint64Int8MapValue {
	s := &uint64Int8MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Int8MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		val := (int8)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Int8MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Int8MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Int8MapValue) Type() string { return "map[uint64]int8" }

func (v *uint64Int8MapValue) IsCumulative() bool {
	return true
}

// -- int16 Value.
type int16Value struct {
	value *int16
}

var _ Value = (*int16Value)(nil)
var _ Getter = (*int16Value)(nil)

func newInt16Value(p *int16) *int16Value {
	return &int16Value{value: p}
}

func (v *int16Value) Set(s string) error {

	parsed, err := strconv.ParseInt(s, 0, 16)
	if err == nil {

		*v.value = (int16)(parsed)

		return nil
	}

	return err

}

func (v *int16Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *int16Value) String() string {
	if v != nil && v.value != nil {

		return strconv.Itoa(int(*v.value))
	}

	return ""
}

func (v *int16Value) Type() string { return "int16" }

// -- int16Slice Value

type int16SliceValue struct {
	value     *[]int16
	changed   bool
	separator string
}

var _ RepeatableFlag = (*int16SliceValue)(nil)
var _ Value = (*int16SliceValue)(nil)
var _ Getter = (*int16SliceValue)(nil)

func newInt16SliceValue(slice *[]int16, sep *string) *int16SliceValue {
	s := &int16SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]int16, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		out[i] = (int16)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *int16SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]int16)(nil)
}

func (v *int16SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt16Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *int16SliceValue) Type() string { return "int16Slice" }

func (v *int16SliceValue) IsCumulative() bool {
	return true
}

// -- stringInt16MapValue.
type stringInt16MapValue struct {
	value     *map[string]int16
	separator string
}

var _ RepeatableFlag = (*stringInt16MapValue)(nil)
var _ Value = (*stringInt16MapValue)(nil)
var _ Getter = (*stringInt16MapValue)(nil)

func newStringInt16MapValue(m *map[string]int16, sep *string) *stringInt16MapValue {
	s := &stringInt16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringInt16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringInt16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringInt16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringInt16MapValue) Type() string { return "map[string]int16" }

func (v *stringInt16MapValue) IsCumulative() bool {
	return true
}

// -- intInt16MapValue.
type intInt16MapValue struct {
	value     *map[int]int16
	separator string
}

var _ RepeatableFlag = (*intInt16MapValue)(nil)
var _ Value = (*intInt16MapValue)(nil)
var _ Getter = (*intInt16MapValue)(nil)

func newIntInt16MapValue(m *map[int]int16, sep *string) *intInt16MapValue {
	s := &intInt16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intInt16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intInt16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intInt16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intInt16MapValue) Type() string { return "map[int]int16" }

func (v *intInt16MapValue) IsCumulative() bool {
	return true
}

// -- int8Int16MapValue.
type int8Int16MapValue struct {
	value     *map[int8]int16
	separator string
}

var _ RepeatableFlag = (*int8Int16MapValue)(nil)
var _ Value = (*int8Int16MapValue)(nil)
var _ Getter = (*int8Int16MapValue)(nil)

func newInt8Int16MapValue(m *map[int8]int16, sep *string) *int8Int16MapValue {
	s := &int8Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Int16MapValue) Type() string { return "map[int8]int16" }

func (v *int8Int16MapValue) IsCumulative() bool {
	return true
}

// -- int16Int16MapValue.
type int16Int16MapValue struct {
	value     *map[int16]int16
	separator string
}

var _ RepeatableFlag = (*int16Int16MapValue)(nil)
var _ Value = (*int16Int16MapValue)(nil)
var _ Getter = (*int16Int16MapValue)(nil)

func newInt16Int16MapValue(m *map[int16]int16, sep *string) *int16Int16MapValue {
	s := &int16Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Int16MapValue) Type() string { return "map[int16]int16" }

func (v *int16Int16MapValue) IsCumulative() bool {
	return true
}

// -- int32Int16MapValue.
type int32Int16MapValue struct {
	value     *map[int32]int16
	separator string
}

var _ RepeatableFlag = (*int32Int16MapValue)(nil)
var _ Value = (*int32Int16MapValue)(nil)
var _ Getter = (*int32Int16MapValue)(nil)

func newInt32Int16MapValue(m *map[int32]int16, sep *string) *int32Int16MapValue {
	s := &int32Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Int16MapValue) Type() string { return "map[int32]int16" }

func (v *int32Int16MapValue) IsCumulative() bool {
	return true
}

// -- int64Int16MapValue.
type int64Int16MapValue struct {
	value     *map[int64]int16
	separator string
}

var _ RepeatableFlag = (*int64Int16MapValue)(nil)
var _ Value = (*int64Int16MapValue)(nil)
var _ Getter = (*int64Int16MapValue)(nil)

func newInt64Int16MapValue(m *map[int64]int16, sep *string) *int64Int16MapValue {
	s := &int64Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Int16MapValue) Type() string { return "map[int64]int16" }

func (v *int64Int16MapValue) IsCumulative() bool {
	return true
}

// -- uintInt16MapValue.
type uintInt16MapValue struct {
	value     *map[uint]int16
	separator string
}

var _ RepeatableFlag = (*uintInt16MapValue)(nil)
var _ Value = (*uintInt16MapValue)(nil)
var _ Getter = (*uintInt16MapValue)(nil)

func newUintInt16MapValue(m *map[uint]int16, sep *string) *uintInt16MapValue {
	s := &uintInt16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintInt16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintInt16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintInt16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintInt16MapValue) Type() string { return "map[uint]int16" }

func (v *uintInt16MapValue) IsCumulative() bool {
	return true
}

// -- uint8Int16MapValue.
type uint8Int16MapValue struct {
	value     *map[uint8]int16
	separator string
}

var _ RepeatableFlag = (*uint8Int16MapValue)(nil)
var _ Value = (*uint8Int16MapValue)(nil)
var _ Getter = (*uint8Int16MapValue)(nil)

func newUint8Int16MapValue(m *map[uint8]int16, sep *string) *uint8Int16MapValue {
	s := &uint8Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Int16MapValue) Type() string { return "map[uint8]int16" }

func (v *uint8Int16MapValue) IsCumulative() bool {
	return true
}

// -- uint16Int16MapValue.
type uint16Int16MapValue struct {
	value     *map[uint16]int16
	separator string
}

var _ RepeatableFlag = (*uint16Int16MapValue)(nil)
var _ Value = (*uint16Int16MapValue)(nil)
var _ Getter = (*uint16Int16MapValue)(nil)

func newUint16Int16MapValue(m *map[uint16]int16, sep *string) *uint16Int16MapValue {
	s := &uint16Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Int16MapValue) Type() string { return "map[uint16]int16" }

func (v *uint16Int16MapValue) IsCumulative() bool {
	return true
}

// -- uint32Int16MapValue.
type uint32Int16MapValue struct {
	value     *map[uint32]int16
	separator string
}

var _ RepeatableFlag = (*uint32Int16MapValue)(nil)
var _ Value = (*uint32Int16MapValue)(nil)
var _ Getter = (*uint32Int16MapValue)(nil)

func newUint32Int16MapValue(m *map[uint32]int16, sep *string) *uint32Int16MapValue {
	s := &uint32Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Int16MapValue) Type() string { return "map[uint32]int16" }

func (v *uint32Int16MapValue) IsCumulative() bool {
	return true
}

// -- uint64Int16MapValue.
type uint64Int16MapValue struct {
	value     *map[uint64]int16
	separator string
}

var _ RepeatableFlag = (*uint64Int16MapValue)(nil)
var _ Value = (*uint64Int16MapValue)(nil)
var _ Getter = (*uint64Int16MapValue)(nil)

func newUint64Int16MapValue(m *map[uint64]int16, sep *string) *uint64Int16MapValue {
	s := &uint64Int16MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Int16MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		val := (int16)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Int16MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Int16MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Int16MapValue) Type() string { return "map[uint64]int16" }

func (v *uint64Int16MapValue) IsCumulative() bool {
	return true
}

// -- int32 Value.
type int32Value struct {
	value *int32
}

var _ Value = (*int32Value)(nil)
var _ Getter = (*int32Value)(nil)

func newInt32Value(p *int32) *int32Value {
	return &int32Value{value: p}
}

func (v *int32Value) Set(s string) error {

	parsed, err := strconv.ParseInt(s, 0, 32)
	if err == nil {

		*v.value = (int32)(parsed)

		return nil
	}

	return err

}

func (v *int32Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *int32Value) String() string {
	if v != nil && v.value != nil {

		return strconv.Itoa(int(*v.value))
	}

	return ""
}

func (v *int32Value) Type() string { return "int32" }

// -- int32Slice Value

type int32SliceValue struct {
	value     *[]int32
	changed   bool
	separator string
}

var _ RepeatableFlag = (*int32SliceValue)(nil)
var _ Value = (*int32SliceValue)(nil)
var _ Getter = (*int32SliceValue)(nil)

func newInt32SliceValue(slice *[]int32, sep *string) *int32SliceValue {
	s := &int32SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]int32, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		out[i] = (int32)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *int32SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]int32)(nil)
}

func (v *int32SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt32Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *int32SliceValue) Type() string { return "int32Slice" }

func (v *int32SliceValue) IsCumulative() bool {
	return true
}

// -- stringInt32MapValue.
type stringInt32MapValue struct {
	value     *map[string]int32
	separator string
}

var _ RepeatableFlag = (*stringInt32MapValue)(nil)
var _ Value = (*stringInt32MapValue)(nil)
var _ Getter = (*stringInt32MapValue)(nil)

func newStringInt32MapValue(m *map[string]int32, sep *string) *stringInt32MapValue {
	s := &stringInt32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringInt32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringInt32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringInt32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringInt32MapValue) Type() string { return "map[string]int32" }

func (v *stringInt32MapValue) IsCumulative() bool {
	return true
}

// -- intInt32MapValue.
type intInt32MapValue struct {
	value     *map[int]int32
	separator string
}

var _ RepeatableFlag = (*intInt32MapValue)(nil)
var _ Value = (*intInt32MapValue)(nil)
var _ Getter = (*intInt32MapValue)(nil)

func newIntInt32MapValue(m *map[int]int32, sep *string) *intInt32MapValue {
	s := &intInt32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intInt32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intInt32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intInt32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intInt32MapValue) Type() string { return "map[int]int32" }

func (v *intInt32MapValue) IsCumulative() bool {
	return true
}

// -- int8Int32MapValue.
type int8Int32MapValue struct {
	value     *map[int8]int32
	separator string
}

var _ RepeatableFlag = (*int8Int32MapValue)(nil)
var _ Value = (*int8Int32MapValue)(nil)
var _ Getter = (*int8Int32MapValue)(nil)

func newInt8Int32MapValue(m *map[int8]int32, sep *string) *int8Int32MapValue {
	s := &int8Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Int32MapValue) Type() string { return "map[int8]int32" }

func (v *int8Int32MapValue) IsCumulative() bool {
	return true
}

// -- int16Int32MapValue.
type int16Int32MapValue struct {
	value     *map[int16]int32
	separator string
}

var _ RepeatableFlag = (*int16Int32MapValue)(nil)
var _ Value = (*int16Int32MapValue)(nil)
var _ Getter = (*int16Int32MapValue)(nil)

func newInt16Int32MapValue(m *map[int16]int32, sep *string) *int16Int32MapValue {
	s := &int16Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Int32MapValue) Type() string { return "map[int16]int32" }

func (v *int16Int32MapValue) IsCumulative() bool {
	return true
}

// -- int32Int32MapValue.
type int32Int32MapValue struct {
	value     *map[int32]int32
	separator string
}

var _ RepeatableFlag = (*int32Int32MapValue)(nil)
var _ Value = (*int32Int32MapValue)(nil)
var _ Getter = (*int32Int32MapValue)(nil)

func newInt32Int32MapValue(m *map[int32]int32, sep *string) *int32Int32MapValue {
	s := &int32Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Int32MapValue) Type() string { return "map[int32]int32" }

func (v *int32Int32MapValue) IsCumulative() bool {
	return true
}

// -- int64Int32MapValue.
type int64Int32MapValue struct {
	value     *map[int64]int32
	separator string
}

var _ RepeatableFlag = (*int64Int32MapValue)(nil)
var _ Value = (*int64Int32MapValue)(nil)
var _ Getter = (*int64Int32MapValue)(nil)

func newInt64Int32MapValue(m *map[int64]int32, sep *string) *int64Int32MapValue {
	s := &int64Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Int32MapValue) Type() string { return "map[int64]int32" }

func (v *int64Int32MapValue) IsCumulative() bool {
	return true
}

// -- uintInt32MapValue.
type uintInt32MapValue struct {
	value     *map[uint]int32
	separator string
}

var _ RepeatableFlag = (*uintInt32MapValue)(nil)
var _ Value = (*uintInt32MapValue)(nil)
var _ Getter = (*uintInt32MapValue)(nil)

func newUintInt32MapValue(m *map[uint]int32, sep *string) *uintInt32MapValue {
	s := &uintInt32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintInt32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintInt32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintInt32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintInt32MapValue) Type() string { return "map[uint]int32" }

func (v *uintInt32MapValue) IsCumulative() bool {
	return true
}

// -- uint8Int32MapValue.
type uint8Int32MapValue struct {
	value     *map[uint8]int32
	separator string
}

var _ RepeatableFlag = (*uint8Int32MapValue)(nil)
var _ Value = (*uint8Int32MapValue)(nil)
var _ Getter = (*uint8Int32MapValue)(nil)

func newUint8Int32MapValue(m *map[uint8]int32, sep *string) *uint8Int32MapValue {
	s := &uint8Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Int32MapValue) Type() string { return "map[uint8]int32" }

func (v *uint8Int32MapValue) IsCumulative() bool {
	return true
}

// -- uint16Int32MapValue.
type uint16Int32MapValue struct {
	value     *map[uint16]int32
	separator string
}

var _ RepeatableFlag = (*uint16Int32MapValue)(nil)
var _ Value = (*uint16Int32MapValue)(nil)
var _ Getter = (*uint16Int32MapValue)(nil)

func newUint16Int32MapValue(m *map[uint16]int32, sep *string) *uint16Int32MapValue {
	s := &uint16Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Int32MapValue) Type() string { return "map[uint16]int32" }

func (v *uint16Int32MapValue) IsCumulative() bool {
	return true
}

// -- uint32Int32MapValue.
type uint32Int32MapValue struct {
	value     *map[uint32]int32
	separator string
}

var _ RepeatableFlag = (*uint32Int32MapValue)(nil)
var _ Value = (*uint32Int32MapValue)(nil)
var _ Getter = (*uint32Int32MapValue)(nil)

func newUint32Int32MapValue(m *map[uint32]int32, sep *string) *uint32Int32MapValue {
	s := &uint32Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Int32MapValue) Type() string { return "map[uint32]int32" }

func (v *uint32Int32MapValue) IsCumulative() bool {
	return true
}

// -- uint64Int32MapValue.
type uint64Int32MapValue struct {
	value     *map[uint64]int32
	separator string
}

var _ RepeatableFlag = (*uint64Int32MapValue)(nil)
var _ Value = (*uint64Int32MapValue)(nil)
var _ Getter = (*uint64Int32MapValue)(nil)

func newUint64Int32MapValue(m *map[uint64]int32, sep *string) *uint64Int32MapValue {
	s := &uint64Int32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Int32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		val := (int32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Int32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Int32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Int32MapValue) Type() string { return "map[uint64]int32" }

func (v *uint64Int32MapValue) IsCumulative() bool {
	return true
}

// -- int64 Value.
type int64Value struct {
	value *int64
}

var _ Value = (*int64Value)(nil)
var _ Getter = (*int64Value)(nil)

func newInt64Value(p *int64) *int64Value {
	return &int64Value{value: p}
}

func (v *int64Value) Set(s string) error {

	parsed, err := strconv.ParseInt(s, 0, 64)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *int64Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *int64Value) String() string {
	if v != nil && v.value != nil {

		return strconv.FormatInt(*v.value, 10)
	}

	return ""
}

func (v *int64Value) Type() string { return "int64" }

// -- int64Slice Value

type int64SliceValue struct {
	value     *[]int64
	changed   bool
	separator string
}

var _ RepeatableFlag = (*int64SliceValue)(nil)
var _ Value = (*int64SliceValue)(nil)
var _ Getter = (*int64SliceValue)(nil)

func newInt64SliceValue(slice *[]int64, sep *string) *int64SliceValue {
	s := &int64SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]int64, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *int64SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]int64)(nil)
}

func (v *int64SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newInt64Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *int64SliceValue) Type() string { return "int64Slice" }

func (v *int64SliceValue) IsCumulative() bool {
	return true
}

// -- stringInt64MapValue.
type stringInt64MapValue struct {
	value     *map[string]int64
	separator string
}

var _ RepeatableFlag = (*stringInt64MapValue)(nil)
var _ Value = (*stringInt64MapValue)(nil)
var _ Getter = (*stringInt64MapValue)(nil)

func newStringInt64MapValue(m *map[string]int64, sep *string) *stringInt64MapValue {
	s := &stringInt64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringInt64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringInt64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringInt64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringInt64MapValue) Type() string { return "map[string]int64" }

func (v *stringInt64MapValue) IsCumulative() bool {
	return true
}

// -- intInt64MapValue.
type intInt64MapValue struct {
	value     *map[int]int64
	separator string
}

var _ RepeatableFlag = (*intInt64MapValue)(nil)
var _ Value = (*intInt64MapValue)(nil)
var _ Getter = (*intInt64MapValue)(nil)

func newIntInt64MapValue(m *map[int]int64, sep *string) *intInt64MapValue {
	s := &intInt64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intInt64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intInt64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intInt64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intInt64MapValue) Type() string { return "map[int]int64" }

func (v *intInt64MapValue) IsCumulative() bool {
	return true
}

// -- int8Int64MapValue.
type int8Int64MapValue struct {
	value     *map[int8]int64
	separator string
}

var _ RepeatableFlag = (*int8Int64MapValue)(nil)
var _ Value = (*int8Int64MapValue)(nil)
var _ Getter = (*int8Int64MapValue)(nil)

func newInt8Int64MapValue(m *map[int8]int64, sep *string) *int8Int64MapValue {
	s := &int8Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Int64MapValue) Type() string { return "map[int8]int64" }

func (v *int8Int64MapValue) IsCumulative() bool {
	return true
}

// -- int16Int64MapValue.
type int16Int64MapValue struct {
	value     *map[int16]int64
	separator string
}

var _ RepeatableFlag = (*int16Int64MapValue)(nil)
var _ Value = (*int16Int64MapValue)(nil)
var _ Getter = (*int16Int64MapValue)(nil)

func newInt16Int64MapValue(m *map[int16]int64, sep *string) *int16Int64MapValue {
	s := &int16Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Int64MapValue) Type() string { return "map[int16]int64" }

func (v *int16Int64MapValue) IsCumulative() bool {
	return true
}

// -- int32Int64MapValue.
type int32Int64MapValue struct {
	value     *map[int32]int64
	separator string
}

var _ RepeatableFlag = (*int32Int64MapValue)(nil)
var _ Value = (*int32Int64MapValue)(nil)
var _ Getter = (*int32Int64MapValue)(nil)

func newInt32Int64MapValue(m *map[int32]int64, sep *string) *int32Int64MapValue {
	s := &int32Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Int64MapValue) Type() string { return "map[int32]int64" }

func (v *int32Int64MapValue) IsCumulative() bool {
	return true
}

// -- int64Int64MapValue.
type int64Int64MapValue struct {
	value     *map[int64]int64
	separator string
}

var _ RepeatableFlag = (*int64Int64MapValue)(nil)
var _ Value = (*int64Int64MapValue)(nil)
var _ Getter = (*int64Int64MapValue)(nil)

func newInt64Int64MapValue(m *map[int64]int64, sep *string) *int64Int64MapValue {
	s := &int64Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Int64MapValue) Type() string { return "map[int64]int64" }

func (v *int64Int64MapValue) IsCumulative() bool {
	return true
}

// -- uintInt64MapValue.
type uintInt64MapValue struct {
	value     *map[uint]int64
	separator string
}

var _ RepeatableFlag = (*uintInt64MapValue)(nil)
var _ Value = (*uintInt64MapValue)(nil)
var _ Getter = (*uintInt64MapValue)(nil)

func newUintInt64MapValue(m *map[uint]int64, sep *string) *uintInt64MapValue {
	s := &uintInt64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintInt64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintInt64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintInt64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintInt64MapValue) Type() string { return "map[uint]int64" }

func (v *uintInt64MapValue) IsCumulative() bool {
	return true
}

// -- uint8Int64MapValue.
type uint8Int64MapValue struct {
	value     *map[uint8]int64
	separator string
}

var _ RepeatableFlag = (*uint8Int64MapValue)(nil)
var _ Value = (*uint8Int64MapValue)(nil)
var _ Getter = (*uint8Int64MapValue)(nil)

func newUint8Int64MapValue(m *map[uint8]int64, sep *string) *uint8Int64MapValue {
	s := &uint8Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Int64MapValue) Type() string { return "map[uint8]int64" }

func (v *uint8Int64MapValue) IsCumulative() bool {
	return true
}

// -- uint16Int64MapValue.
type uint16Int64MapValue struct {
	value     *map[uint16]int64
	separator string
}

var _ RepeatableFlag = (*uint16Int64MapValue)(nil)
var _ Value = (*uint16Int64MapValue)(nil)
var _ Getter = (*uint16Int64MapValue)(nil)

func newUint16Int64MapValue(m *map[uint16]int64, sep *string) *uint16Int64MapValue {
	s := &uint16Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Int64MapValue) Type() string { return "map[uint16]int64" }

func (v *uint16Int64MapValue) IsCumulative() bool {
	return true
}

// -- uint32Int64MapValue.
type uint32Int64MapValue struct {
	value     *map[uint32]int64
	separator string
}

var _ RepeatableFlag = (*uint32Int64MapValue)(nil)
var _ Value = (*uint32Int64MapValue)(nil)
var _ Getter = (*uint32Int64MapValue)(nil)

func newUint32Int64MapValue(m *map[uint32]int64, sep *string) *uint32Int64MapValue {
	s := &uint32Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Int64MapValue) Type() string { return "map[uint32]int64" }

func (v *uint32Int64MapValue) IsCumulative() bool {
	return true
}

// -- uint64Int64MapValue.
type uint64Int64MapValue struct {
	value     *map[uint64]int64
	separator string
}

var _ RepeatableFlag = (*uint64Int64MapValue)(nil)
var _ Value = (*uint64Int64MapValue)(nil)
var _ Getter = (*uint64Int64MapValue)(nil)

func newUint64Int64MapValue(m *map[uint64]int64, sep *string) *uint64Int64MapValue {
	s := &uint64Int64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Int64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Int64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Int64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Int64MapValue) Type() string { return "map[uint64]int64" }

func (v *uint64Int64MapValue) IsCumulative() bool {
	return true
}

// -- float64 Value.
type float64Value struct {
	value *float64
}

var _ Value = (*float64Value)(nil)
var _ Getter = (*float64Value)(nil)

func newFloat64Value(p *float64) *float64Value {
	return &float64Value{value: p}
}

func (v *float64Value) Set(s string) error {

	parsed, err := strconv.ParseFloat(s, 64)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *float64Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *float64Value) String() string {
	if v != nil && v.value != nil {

		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *float64Value) Type() string { return "float64" }

// -- float64Slice Value

type float64SliceValue struct {
	value     *[]float64
	changed   bool
	separator string
}

var _ RepeatableFlag = (*float64SliceValue)(nil)
var _ Value = (*float64SliceValue)(nil)
var _ Getter = (*float64SliceValue)(nil)

func newFloat64SliceValue(slice *[]float64, sep *string) *float64SliceValue {
	s := &float64SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *float64SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]float64, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *float64SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]float64)(nil)
}

func (v *float64SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newFloat64Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *float64SliceValue) Type() string { return "float64Slice" }

func (v *float64SliceValue) IsCumulative() bool {
	return true
}

// -- stringFloat64MapValue.
type stringFloat64MapValue struct {
	value     *map[string]float64
	separator string
}

var _ RepeatableFlag = (*stringFloat64MapValue)(nil)
var _ Value = (*stringFloat64MapValue)(nil)
var _ Getter = (*stringFloat64MapValue)(nil)

func newStringFloat64MapValue(m *map[string]float64, sep *string) *stringFloat64MapValue {
	s := &stringFloat64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringFloat64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringFloat64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringFloat64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringFloat64MapValue) Type() string { return "map[string]float64" }

func (v *stringFloat64MapValue) IsCumulative() bool {
	return true
}

// -- intFloat64MapValue.
type intFloat64MapValue struct {
	value     *map[int]float64
	separator string
}

var _ RepeatableFlag = (*intFloat64MapValue)(nil)
var _ Value = (*intFloat64MapValue)(nil)
var _ Getter = (*intFloat64MapValue)(nil)

func newIntFloat64MapValue(m *map[int]float64, sep *string) *intFloat64MapValue {
	s := &intFloat64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intFloat64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intFloat64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intFloat64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intFloat64MapValue) Type() string { return "map[int]float64" }

func (v *intFloat64MapValue) IsCumulative() bool {
	return true
}

// -- int8Float64MapValue.
type int8Float64MapValue struct {
	value     *map[int8]float64
	separator string
}

var _ RepeatableFlag = (*int8Float64MapValue)(nil)
var _ Value = (*int8Float64MapValue)(nil)
var _ Getter = (*int8Float64MapValue)(nil)

func newInt8Float64MapValue(m *map[int8]float64, sep *string) *int8Float64MapValue {
	s := &int8Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Float64MapValue) Type() string { return "map[int8]float64" }

func (v *int8Float64MapValue) IsCumulative() bool {
	return true
}

// -- int16Float64MapValue.
type int16Float64MapValue struct {
	value     *map[int16]float64
	separator string
}

var _ RepeatableFlag = (*int16Float64MapValue)(nil)
var _ Value = (*int16Float64MapValue)(nil)
var _ Getter = (*int16Float64MapValue)(nil)

func newInt16Float64MapValue(m *map[int16]float64, sep *string) *int16Float64MapValue {
	s := &int16Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Float64MapValue) Type() string { return "map[int16]float64" }

func (v *int16Float64MapValue) IsCumulative() bool {
	return true
}

// -- int32Float64MapValue.
type int32Float64MapValue struct {
	value     *map[int32]float64
	separator string
}

var _ RepeatableFlag = (*int32Float64MapValue)(nil)
var _ Value = (*int32Float64MapValue)(nil)
var _ Getter = (*int32Float64MapValue)(nil)

func newInt32Float64MapValue(m *map[int32]float64, sep *string) *int32Float64MapValue {
	s := &int32Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Float64MapValue) Type() string { return "map[int32]float64" }

func (v *int32Float64MapValue) IsCumulative() bool {
	return true
}

// -- int64Float64MapValue.
type int64Float64MapValue struct {
	value     *map[int64]float64
	separator string
}

var _ RepeatableFlag = (*int64Float64MapValue)(nil)
var _ Value = (*int64Float64MapValue)(nil)
var _ Getter = (*int64Float64MapValue)(nil)

func newInt64Float64MapValue(m *map[int64]float64, sep *string) *int64Float64MapValue {
	s := &int64Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Float64MapValue) Type() string { return "map[int64]float64" }

func (v *int64Float64MapValue) IsCumulative() bool {
	return true
}

// -- uintFloat64MapValue.
type uintFloat64MapValue struct {
	value     *map[uint]float64
	separator string
}

var _ RepeatableFlag = (*uintFloat64MapValue)(nil)
var _ Value = (*uintFloat64MapValue)(nil)
var _ Getter = (*uintFloat64MapValue)(nil)

func newUintFloat64MapValue(m *map[uint]float64, sep *string) *uintFloat64MapValue {
	s := &uintFloat64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintFloat64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintFloat64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintFloat64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintFloat64MapValue) Type() string { return "map[uint]float64" }

func (v *uintFloat64MapValue) IsCumulative() bool {
	return true
}

// -- uint8Float64MapValue.
type uint8Float64MapValue struct {
	value     *map[uint8]float64
	separator string
}

var _ RepeatableFlag = (*uint8Float64MapValue)(nil)
var _ Value = (*uint8Float64MapValue)(nil)
var _ Getter = (*uint8Float64MapValue)(nil)

func newUint8Float64MapValue(m *map[uint8]float64, sep *string) *uint8Float64MapValue {
	s := &uint8Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Float64MapValue) Type() string { return "map[uint8]float64" }

func (v *uint8Float64MapValue) IsCumulative() bool {
	return true
}

// -- uint16Float64MapValue.
type uint16Float64MapValue struct {
	value     *map[uint16]float64
	separator string
}

var _ RepeatableFlag = (*uint16Float64MapValue)(nil)
var _ Value = (*uint16Float64MapValue)(nil)
var _ Getter = (*uint16Float64MapValue)(nil)

func newUint16Float64MapValue(m *map[uint16]float64, sep *string) *uint16Float64MapValue {
	s := &uint16Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Float64MapValue) Type() string { return "map[uint16]float64" }

func (v *uint16Float64MapValue) IsCumulative() bool {
	return true
}

// -- uint32Float64MapValue.
type uint32Float64MapValue struct {
	value     *map[uint32]float64
	separator string
}

var _ RepeatableFlag = (*uint32Float64MapValue)(nil)
var _ Value = (*uint32Float64MapValue)(nil)
var _ Getter = (*uint32Float64MapValue)(nil)

func newUint32Float64MapValue(m *map[uint32]float64, sep *string) *uint32Float64MapValue {
	s := &uint32Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Float64MapValue) Type() string { return "map[uint32]float64" }

func (v *uint32Float64MapValue) IsCumulative() bool {
	return true
}

// -- uint64Float64MapValue.
type uint64Float64MapValue struct {
	value     *map[uint64]float64
	separator string
}

var _ RepeatableFlag = (*uint64Float64MapValue)(nil)
var _ Value = (*uint64Float64MapValue)(nil)
var _ Getter = (*uint64Float64MapValue)(nil)

func newUint64Float64MapValue(m *map[uint64]float64, sep *string) *uint64Float64MapValue {
	s := &uint64Float64MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Float64MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Float64MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Float64MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Float64MapValue) Type() string { return "map[uint64]float64" }

func (v *uint64Float64MapValue) IsCumulative() bool {
	return true
}

// -- float32 Value.
type float32Value struct {
	value *float32
}

var _ Value = (*float32Value)(nil)
var _ Getter = (*float32Value)(nil)

func newFloat32Value(p *float32) *float32Value {
	return &float32Value{value: p}
}

func (v *float32Value) Set(s string) error {

	parsed, err := strconv.ParseFloat(s, 32)
	if err == nil {

		*v.value = (float32)(parsed)

		return nil
	}

	return err

}

func (v *float32Value) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *float32Value) String() string {
	if v != nil && v.value != nil {

		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *float32Value) Type() string { return "float32" }

// -- float32Slice Value

type float32SliceValue struct {
	value     *[]float32
	changed   bool
	separator string
}

var _ RepeatableFlag = (*float32SliceValue)(nil)
var _ Value = (*float32SliceValue)(nil)
var _ Getter = (*float32SliceValue)(nil)

func newFloat32SliceValue(slice *[]float32, sep *string) *float32SliceValue {
	s := &float32SliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *float32SliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]float32, len(ss))
	for i, s := range ss {
		parsed, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		out[i] = (float32)(parsed)

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *float32SliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]float32)(nil)
}

func (v *float32SliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newFloat32Value(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *float32SliceValue) Type() string { return "float32Slice" }

func (v *float32SliceValue) IsCumulative() bool {
	return true
}

// -- stringFloat32MapValue.
type stringFloat32MapValue struct {
	value     *map[string]float32
	separator string
}

var _ RepeatableFlag = (*stringFloat32MapValue)(nil)
var _ Value = (*stringFloat32MapValue)(nil)
var _ Getter = (*stringFloat32MapValue)(nil)

func newStringFloat32MapValue(m *map[string]float32, sep *string) *stringFloat32MapValue {
	s := &stringFloat32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringFloat32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringFloat32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringFloat32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringFloat32MapValue) Type() string { return "map[string]float32" }

func (v *stringFloat32MapValue) IsCumulative() bool {
	return true
}

// -- intFloat32MapValue.
type intFloat32MapValue struct {
	value     *map[int]float32
	separator string
}

var _ RepeatableFlag = (*intFloat32MapValue)(nil)
var _ Value = (*intFloat32MapValue)(nil)
var _ Getter = (*intFloat32MapValue)(nil)

func newIntFloat32MapValue(m *map[int]float32, sep *string) *intFloat32MapValue {
	s := &intFloat32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intFloat32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *intFloat32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intFloat32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intFloat32MapValue) Type() string { return "map[int]float32" }

func (v *intFloat32MapValue) IsCumulative() bool {
	return true
}

// -- int8Float32MapValue.
type int8Float32MapValue struct {
	value     *map[int8]float32
	separator string
}

var _ RepeatableFlag = (*int8Float32MapValue)(nil)
var _ Value = (*int8Float32MapValue)(nil)
var _ Getter = (*int8Float32MapValue)(nil)

func newInt8Float32MapValue(m *map[int8]float32, sep *string) *int8Float32MapValue {
	s := &int8Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8Float32MapValue) Type() string { return "map[int8]float32" }

func (v *int8Float32MapValue) IsCumulative() bool {
	return true
}

// -- int16Float32MapValue.
type int16Float32MapValue struct {
	value     *map[int16]float32
	separator string
}

var _ RepeatableFlag = (*int16Float32MapValue)(nil)
var _ Value = (*int16Float32MapValue)(nil)
var _ Getter = (*int16Float32MapValue)(nil)

func newInt16Float32MapValue(m *map[int16]float32, sep *string) *int16Float32MapValue {
	s := &int16Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16Float32MapValue) Type() string { return "map[int16]float32" }

func (v *int16Float32MapValue) IsCumulative() bool {
	return true
}

// -- int32Float32MapValue.
type int32Float32MapValue struct {
	value     *map[int32]float32
	separator string
}

var _ RepeatableFlag = (*int32Float32MapValue)(nil)
var _ Value = (*int32Float32MapValue)(nil)
var _ Getter = (*int32Float32MapValue)(nil)

func newInt32Float32MapValue(m *map[int32]float32, sep *string) *int32Float32MapValue {
	s := &int32Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32Float32MapValue) Type() string { return "map[int32]float32" }

func (v *int32Float32MapValue) IsCumulative() bool {
	return true
}

// -- int64Float32MapValue.
type int64Float32MapValue struct {
	value     *map[int64]float32
	separator string
}

var _ RepeatableFlag = (*int64Float32MapValue)(nil)
var _ Value = (*int64Float32MapValue)(nil)
var _ Getter = (*int64Float32MapValue)(nil)

func newInt64Float32MapValue(m *map[int64]float32, sep *string) *int64Float32MapValue {
	s := &int64Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64Float32MapValue) Type() string { return "map[int64]float32" }

func (v *int64Float32MapValue) IsCumulative() bool {
	return true
}

// -- uintFloat32MapValue.
type uintFloat32MapValue struct {
	value     *map[uint]float32
	separator string
}

var _ RepeatableFlag = (*uintFloat32MapValue)(nil)
var _ Value = (*uintFloat32MapValue)(nil)
var _ Getter = (*uintFloat32MapValue)(nil)

func newUintFloat32MapValue(m *map[uint]float32, sep *string) *uintFloat32MapValue {
	s := &uintFloat32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintFloat32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintFloat32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintFloat32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintFloat32MapValue) Type() string { return "map[uint]float32" }

func (v *uintFloat32MapValue) IsCumulative() bool {
	return true
}

// -- uint8Float32MapValue.
type uint8Float32MapValue struct {
	value     *map[uint8]float32
	separator string
}

var _ RepeatableFlag = (*uint8Float32MapValue)(nil)
var _ Value = (*uint8Float32MapValue)(nil)
var _ Getter = (*uint8Float32MapValue)(nil)

func newUint8Float32MapValue(m *map[uint8]float32, sep *string) *uint8Float32MapValue {
	s := &uint8Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8Float32MapValue) Type() string { return "map[uint8]float32" }

func (v *uint8Float32MapValue) IsCumulative() bool {
	return true
}

// -- uint16Float32MapValue.
type uint16Float32MapValue struct {
	value     *map[uint16]float32
	separator string
}

var _ RepeatableFlag = (*uint16Float32MapValue)(nil)
var _ Value = (*uint16Float32MapValue)(nil)
var _ Getter = (*uint16Float32MapValue)(nil)

func newUint16Float32MapValue(m *map[uint16]float32, sep *string) *uint16Float32MapValue {
	s := &uint16Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16Float32MapValue) Type() string { return "map[uint16]float32" }

func (v *uint16Float32MapValue) IsCumulative() bool {
	return true
}

// -- uint32Float32MapValue.
type uint32Float32MapValue struct {
	value     *map[uint32]float32
	separator string
}

var _ RepeatableFlag = (*uint32Float32MapValue)(nil)
var _ Value = (*uint32Float32MapValue)(nil)
var _ Getter = (*uint32Float32MapValue)(nil)

func newUint32Float32MapValue(m *map[uint32]float32, sep *string) *uint32Float32MapValue {
	s := &uint32Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32Float32MapValue) Type() string { return "map[uint32]float32" }

func (v *uint32Float32MapValue) IsCumulative() bool {
	return true
}

// -- uint64Float32MapValue.
type uint64Float32MapValue struct {
	value     *map[uint64]float32
	separator string
}

var _ RepeatableFlag = (*uint64Float32MapValue)(nil)
var _ Value = (*uint64Float32MapValue)(nil)
var _ Getter = (*uint64Float32MapValue)(nil)

func newUint64Float32MapValue(m *map[uint64]float32, sep *string) *uint64Float32MapValue {
	s := &uint64Float32MapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64Float32MapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := strconv.ParseFloat(s, 32)
		if err != nil {
			return err
		}

		val := (float32)(parsedVal)

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64Float32MapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64Float32MapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64Float32MapValue) Type() string { return "map[uint64]float32" }

func (v *uint64Float32MapValue) IsCumulative() bool {
	return true
}

// -- time.Duration Value.
type durationValue struct {
	value *time.Duration
}

var _ Value = (*durationValue)(nil)
var _ Getter = (*durationValue)(nil)

func newDurationValue(p *time.Duration) *durationValue {
	return &durationValue{value: p}
}

func (v *durationValue) Set(s string) error {

	parsed, err := time.ParseDuration(s)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *durationValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *durationValue) String() string {
	if v != nil && v.value != nil {

		return (*v.value).String()
	}

	return ""
}

func (v *durationValue) Type() string { return "duration" }

// -- time.DurationSlice Value

type durationSliceValue struct {
	value     *[]time.Duration
	changed   bool
	separator string
}

var _ RepeatableFlag = (*durationSliceValue)(nil)
var _ Value = (*durationSliceValue)(nil)
var _ Getter = (*durationSliceValue)(nil)

func newDurationSliceValue(slice *[]time.Duration, sep *string) *durationSliceValue {
	s := &durationSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *durationSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]time.Duration, len(ss))
	for i, s := range ss {
		parsed, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *durationSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]time.Duration)(nil)
}

func (v *durationSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newDurationValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *durationSliceValue) Type() string { return "durationSlice" }

func (v *durationSliceValue) IsCumulative() bool {
	return true
}

// -- stringDurationMapValue.
type stringDurationMapValue struct {
	value     *map[string]time.Duration
	separator string
}

var _ RepeatableFlag = (*stringDurationMapValue)(nil)
var _ Value = (*stringDurationMapValue)(nil)
var _ Getter = (*stringDurationMapValue)(nil)

func newStringDurationMapValue(m *map[string]time.Duration, sep *string) *stringDurationMapValue {
	s := &stringDurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringDurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringDurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringDurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringDurationMapValue) Type() string { return "map[string]time.Duration" }

func (v *stringDurationMapValue) IsCumulative() bool {
	return true
}

// -- intDurationMapValue.
type intDurationMapValue struct {
	value     *map[int]time.Duration
	separator string
}

var _ RepeatableFlag = (*intDurationMapValue)(nil)
var _ Value = (*intDurationMapValue)(nil)
var _ Getter = (*intDurationMapValue)(nil)

func newIntDurationMapValue(m *map[int]time.Duration, sep *string) *intDurationMapValue {
	s := &intDurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intDurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intDurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intDurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intDurationMapValue) Type() string { return "map[int]time.Duration" }

func (v *intDurationMapValue) IsCumulative() bool {
	return true
}

// -- int8DurationMapValue.
type int8DurationMapValue struct {
	value     *map[int8]time.Duration
	separator string
}

var _ RepeatableFlag = (*int8DurationMapValue)(nil)
var _ Value = (*int8DurationMapValue)(nil)
var _ Getter = (*int8DurationMapValue)(nil)

func newInt8DurationMapValue(m *map[int8]time.Duration, sep *string) *int8DurationMapValue {
	s := &int8DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8DurationMapValue) Type() string { return "map[int8]time.Duration" }

func (v *int8DurationMapValue) IsCumulative() bool {
	return true
}

// -- int16DurationMapValue.
type int16DurationMapValue struct {
	value     *map[int16]time.Duration
	separator string
}

var _ RepeatableFlag = (*int16DurationMapValue)(nil)
var _ Value = (*int16DurationMapValue)(nil)
var _ Getter = (*int16DurationMapValue)(nil)

func newInt16DurationMapValue(m *map[int16]time.Duration, sep *string) *int16DurationMapValue {
	s := &int16DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16DurationMapValue) Type() string { return "map[int16]time.Duration" }

func (v *int16DurationMapValue) IsCumulative() bool {
	return true
}

// -- int32DurationMapValue.
type int32DurationMapValue struct {
	value     *map[int32]time.Duration
	separator string
}

var _ RepeatableFlag = (*int32DurationMapValue)(nil)
var _ Value = (*int32DurationMapValue)(nil)
var _ Getter = (*int32DurationMapValue)(nil)

func newInt32DurationMapValue(m *map[int32]time.Duration, sep *string) *int32DurationMapValue {
	s := &int32DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32DurationMapValue) Type() string { return "map[int32]time.Duration" }

func (v *int32DurationMapValue) IsCumulative() bool {
	return true
}

// -- int64DurationMapValue.
type int64DurationMapValue struct {
	value     *map[int64]time.Duration
	separator string
}

var _ RepeatableFlag = (*int64DurationMapValue)(nil)
var _ Value = (*int64DurationMapValue)(nil)
var _ Getter = (*int64DurationMapValue)(nil)

func newInt64DurationMapValue(m *map[int64]time.Duration, sep *string) *int64DurationMapValue {
	s := &int64DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64DurationMapValue) Type() string { return "map[int64]time.Duration" }

func (v *int64DurationMapValue) IsCumulative() bool {
	return true
}

// -- uintDurationMapValue.
type uintDurationMapValue struct {
	value     *map[uint]time.Duration
	separator string
}

var _ RepeatableFlag = (*uintDurationMapValue)(nil)
var _ Value = (*uintDurationMapValue)(nil)
var _ Getter = (*uintDurationMapValue)(nil)

func newUintDurationMapValue(m *map[uint]time.Duration, sep *string) *uintDurationMapValue {
	s := &uintDurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintDurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintDurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintDurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintDurationMapValue) Type() string { return "map[uint]time.Duration" }

func (v *uintDurationMapValue) IsCumulative() bool {
	return true
}

// -- uint8DurationMapValue.
type uint8DurationMapValue struct {
	value     *map[uint8]time.Duration
	separator string
}

var _ RepeatableFlag = (*uint8DurationMapValue)(nil)
var _ Value = (*uint8DurationMapValue)(nil)
var _ Getter = (*uint8DurationMapValue)(nil)

func newUint8DurationMapValue(m *map[uint8]time.Duration, sep *string) *uint8DurationMapValue {
	s := &uint8DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8DurationMapValue) Type() string { return "map[uint8]time.Duration" }

func (v *uint8DurationMapValue) IsCumulative() bool {
	return true
}

// -- uint16DurationMapValue.
type uint16DurationMapValue struct {
	value     *map[uint16]time.Duration
	separator string
}

var _ RepeatableFlag = (*uint16DurationMapValue)(nil)
var _ Value = (*uint16DurationMapValue)(nil)
var _ Getter = (*uint16DurationMapValue)(nil)

func newUint16DurationMapValue(m *map[uint16]time.Duration, sep *string) *uint16DurationMapValue {
	s := &uint16DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16DurationMapValue) Type() string { return "map[uint16]time.Duration" }

func (v *uint16DurationMapValue) IsCumulative() bool {
	return true
}

// -- uint32DurationMapValue.
type uint32DurationMapValue struct {
	value     *map[uint32]time.Duration
	separator string
}

var _ RepeatableFlag = (*uint32DurationMapValue)(nil)
var _ Value = (*uint32DurationMapValue)(nil)
var _ Getter = (*uint32DurationMapValue)(nil)

func newUint32DurationMapValue(m *map[uint32]time.Duration, sep *string) *uint32DurationMapValue {
	s := &uint32DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32DurationMapValue) Type() string { return "map[uint32]time.Duration" }

func (v *uint32DurationMapValue) IsCumulative() bool {
	return true
}

// -- uint64DurationMapValue.
type uint64DurationMapValue struct {
	value     *map[uint64]time.Duration
	separator string
}

var _ RepeatableFlag = (*uint64DurationMapValue)(nil)
var _ Value = (*uint64DurationMapValue)(nil)
var _ Getter = (*uint64DurationMapValue)(nil)

func newUint64DurationMapValue(m *map[uint64]time.Duration, sep *string) *uint64DurationMapValue {
	s := &uint64DurationMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64DurationMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := time.ParseDuration(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64DurationMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64DurationMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64DurationMapValue) Type() string { return "map[uint64]time.Duration" }

func (v *uint64DurationMapValue) IsCumulative() bool {
	return true
}

// -- net.IP Value.
type ipValue struct {
	value *net.IP
}

var _ Value = (*ipValue)(nil)
var _ Getter = (*ipValue)(nil)

func newIPValue(p *net.IP) *ipValue {
	return &ipValue{value: p}
}

func (v *ipValue) Set(s string) error {

	parsed, err := parseIP(s)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *ipValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *ipValue) String() string {
	if v != nil && v.value != nil {

		return v.value.String()
	}

	return ""
}

func (v *ipValue) Type() string { return "ip" }

// -- net.IPSlice Value

type ipSliceValue struct {
	value     *[]net.IP
	changed   bool
	separator string
}

var _ RepeatableFlag = (*ipSliceValue)(nil)
var _ Value = (*ipSliceValue)(nil)
var _ Getter = (*ipSliceValue)(nil)

func newIPSliceValue(slice *[]net.IP, sep *string) *ipSliceValue {
	s := &ipSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *ipSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]net.IP, len(ss))
	for i, s := range ss {
		parsed, err := parseIP(s)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *ipSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]net.IP)(nil)
}

func (v *ipSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newIPValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *ipSliceValue) Type() string { return "ipSlice" }

func (v *ipSliceValue) IsCumulative() bool {
	return true
}

// -- stringIPMapValue.
type stringIPMapValue struct {
	value     *map[string]net.IP
	separator string
}

var _ RepeatableFlag = (*stringIPMapValue)(nil)
var _ Value = (*stringIPMapValue)(nil)
var _ Getter = (*stringIPMapValue)(nil)

func newStringIPMapValue(m *map[string]net.IP, sep *string) *stringIPMapValue {
	s := &stringIPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringIPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringIPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringIPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringIPMapValue) Type() string { return "map[string]net.IP" }

func (v *stringIPMapValue) IsCumulative() bool {
	return true
}

// -- intIPMapValue.
type intIPMapValue struct {
	value     *map[int]net.IP
	separator string
}

var _ RepeatableFlag = (*intIPMapValue)(nil)
var _ Value = (*intIPMapValue)(nil)
var _ Getter = (*intIPMapValue)(nil)

func newIntIPMapValue(m *map[int]net.IP, sep *string) *intIPMapValue {
	s := &intIPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intIPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intIPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intIPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intIPMapValue) Type() string { return "map[int]net.IP" }

func (v *intIPMapValue) IsCumulative() bool {
	return true
}

// -- int8IPMapValue.
type int8IPMapValue struct {
	value     *map[int8]net.IP
	separator string
}

var _ RepeatableFlag = (*int8IPMapValue)(nil)
var _ Value = (*int8IPMapValue)(nil)
var _ Getter = (*int8IPMapValue)(nil)

func newInt8IPMapValue(m *map[int8]net.IP, sep *string) *int8IPMapValue {
	s := &int8IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8IPMapValue) Type() string { return "map[int8]net.IP" }

func (v *int8IPMapValue) IsCumulative() bool {
	return true
}

// -- int16IPMapValue.
type int16IPMapValue struct {
	value     *map[int16]net.IP
	separator string
}

var _ RepeatableFlag = (*int16IPMapValue)(nil)
var _ Value = (*int16IPMapValue)(nil)
var _ Getter = (*int16IPMapValue)(nil)

func newInt16IPMapValue(m *map[int16]net.IP, sep *string) *int16IPMapValue {
	s := &int16IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16IPMapValue) Type() string { return "map[int16]net.IP" }

func (v *int16IPMapValue) IsCumulative() bool {
	return true
}

// -- int32IPMapValue.
type int32IPMapValue struct {
	value     *map[int32]net.IP
	separator string
}

var _ RepeatableFlag = (*int32IPMapValue)(nil)
var _ Value = (*int32IPMapValue)(nil)
var _ Getter = (*int32IPMapValue)(nil)

func newInt32IPMapValue(m *map[int32]net.IP, sep *string) *int32IPMapValue {
	s := &int32IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32IPMapValue) Type() string { return "map[int32]net.IP" }

func (v *int32IPMapValue) IsCumulative() bool {
	return true
}

// -- int64IPMapValue.
type int64IPMapValue struct {
	value     *map[int64]net.IP
	separator string
}

var _ RepeatableFlag = (*int64IPMapValue)(nil)
var _ Value = (*int64IPMapValue)(nil)
var _ Getter = (*int64IPMapValue)(nil)

func newInt64IPMapValue(m *map[int64]net.IP, sep *string) *int64IPMapValue {
	s := &int64IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64IPMapValue) Type() string { return "map[int64]net.IP" }

func (v *int64IPMapValue) IsCumulative() bool {
	return true
}

// -- uintIPMapValue.
type uintIPMapValue struct {
	value     *map[uint]net.IP
	separator string
}

var _ RepeatableFlag = (*uintIPMapValue)(nil)
var _ Value = (*uintIPMapValue)(nil)
var _ Getter = (*uintIPMapValue)(nil)

func newUintIPMapValue(m *map[uint]net.IP, sep *string) *uintIPMapValue {
	s := &uintIPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintIPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintIPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintIPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintIPMapValue) Type() string { return "map[uint]net.IP" }

func (v *uintIPMapValue) IsCumulative() bool {
	return true
}

// -- uint8IPMapValue.
type uint8IPMapValue struct {
	value     *map[uint8]net.IP
	separator string
}

var _ RepeatableFlag = (*uint8IPMapValue)(nil)
var _ Value = (*uint8IPMapValue)(nil)
var _ Getter = (*uint8IPMapValue)(nil)

func newUint8IPMapValue(m *map[uint8]net.IP, sep *string) *uint8IPMapValue {
	s := &uint8IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8IPMapValue) Type() string { return "map[uint8]net.IP" }

func (v *uint8IPMapValue) IsCumulative() bool {
	return true
}

// -- uint16IPMapValue.
type uint16IPMapValue struct {
	value     *map[uint16]net.IP
	separator string
}

var _ RepeatableFlag = (*uint16IPMapValue)(nil)
var _ Value = (*uint16IPMapValue)(nil)
var _ Getter = (*uint16IPMapValue)(nil)

func newUint16IPMapValue(m *map[uint16]net.IP, sep *string) *uint16IPMapValue {
	s := &uint16IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16IPMapValue) Type() string { return "map[uint16]net.IP" }

func (v *uint16IPMapValue) IsCumulative() bool {
	return true
}

// -- uint32IPMapValue.
type uint32IPMapValue struct {
	value     *map[uint32]net.IP
	separator string
}

var _ RepeatableFlag = (*uint32IPMapValue)(nil)
var _ Value = (*uint32IPMapValue)(nil)
var _ Getter = (*uint32IPMapValue)(nil)

func newUint32IPMapValue(m *map[uint32]net.IP, sep *string) *uint32IPMapValue {
	s := &uint32IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32IPMapValue) Type() string { return "map[uint32]net.IP" }

func (v *uint32IPMapValue) IsCumulative() bool {
	return true
}

// -- uint64IPMapValue.
type uint64IPMapValue struct {
	value     *map[uint64]net.IP
	separator string
}

var _ RepeatableFlag = (*uint64IPMapValue)(nil)
var _ Value = (*uint64IPMapValue)(nil)
var _ Getter = (*uint64IPMapValue)(nil)

func newUint64IPMapValue(m *map[uint64]net.IP, sep *string) *uint64IPMapValue {
	s := &uint64IPMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64IPMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := parseIP(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64IPMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64IPMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64IPMapValue) Type() string { return "map[uint64]net.IP" }

func (v *uint64IPMapValue) IsCumulative() bool {
	return true
}

// -- HexBytes Value.
type hexBytesValue struct {
	value *HexBytes
}

var _ Value = (*hexBytesValue)(nil)
var _ Getter = (*hexBytesValue)(nil)

func newHexBytesValue(p *HexBytes) *hexBytesValue {
	return &hexBytesValue{value: p}
}

func (v *hexBytesValue) Set(s string) error {

	parsed, err := hex.DecodeString(s)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *hexBytesValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *hexBytesValue) String() string {
	if v != nil && v.value != nil {

		return fmt.Sprintf("%x", *v.value)
	}

	return ""
}

func (v *hexBytesValue) Type() string { return "hexBytes" }

// -- HexBytesSlice Value

type hexBytesSliceValue struct {
	value     *[]HexBytes
	changed   bool
	separator string
}

var _ RepeatableFlag = (*hexBytesSliceValue)(nil)
var _ Value = (*hexBytesSliceValue)(nil)
var _ Getter = (*hexBytesSliceValue)(nil)

func newHexBytesSliceValue(slice *[]HexBytes, sep *string) *hexBytesSliceValue {
	s := &hexBytesSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *hexBytesSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]HexBytes, len(ss))
	for i, s := range ss {
		parsed, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *hexBytesSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]HexBytes)(nil)
}

func (v *hexBytesSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newHexBytesValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *hexBytesSliceValue) Type() string { return "hexBytesSlice" }

func (v *hexBytesSliceValue) IsCumulative() bool {
	return true
}

// -- stringHexBytesMapValue.
type stringHexBytesMapValue struct {
	value     *map[string]HexBytes
	separator string
}

var _ RepeatableFlag = (*stringHexBytesMapValue)(nil)
var _ Value = (*stringHexBytesMapValue)(nil)
var _ Getter = (*stringHexBytesMapValue)(nil)

func newStringHexBytesMapValue(m *map[string]HexBytes, sep *string) *stringHexBytesMapValue {
	s := &stringHexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringHexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringHexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringHexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringHexBytesMapValue) Type() string { return "map[string]HexBytes" }

func (v *stringHexBytesMapValue) IsCumulative() bool {
	return true
}

// -- intHexBytesMapValue.
type intHexBytesMapValue struct {
	value     *map[int]HexBytes
	separator string
}

var _ RepeatableFlag = (*intHexBytesMapValue)(nil)
var _ Value = (*intHexBytesMapValue)(nil)
var _ Getter = (*intHexBytesMapValue)(nil)

func newIntHexBytesMapValue(m *map[int]HexBytes, sep *string) *intHexBytesMapValue {
	s := &intHexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intHexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intHexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intHexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intHexBytesMapValue) Type() string { return "map[int]HexBytes" }

func (v *intHexBytesMapValue) IsCumulative() bool {
	return true
}

// -- int8HexBytesMapValue.
type int8HexBytesMapValue struct {
	value     *map[int8]HexBytes
	separator string
}

var _ RepeatableFlag = (*int8HexBytesMapValue)(nil)
var _ Value = (*int8HexBytesMapValue)(nil)
var _ Getter = (*int8HexBytesMapValue)(nil)

func newInt8HexBytesMapValue(m *map[int8]HexBytes, sep *string) *int8HexBytesMapValue {
	s := &int8HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8HexBytesMapValue) Type() string { return "map[int8]HexBytes" }

func (v *int8HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- int16HexBytesMapValue.
type int16HexBytesMapValue struct {
	value     *map[int16]HexBytes
	separator string
}

var _ RepeatableFlag = (*int16HexBytesMapValue)(nil)
var _ Value = (*int16HexBytesMapValue)(nil)
var _ Getter = (*int16HexBytesMapValue)(nil)

func newInt16HexBytesMapValue(m *map[int16]HexBytes, sep *string) *int16HexBytesMapValue {
	s := &int16HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16HexBytesMapValue) Type() string { return "map[int16]HexBytes" }

func (v *int16HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- int32HexBytesMapValue.
type int32HexBytesMapValue struct {
	value     *map[int32]HexBytes
	separator string
}

var _ RepeatableFlag = (*int32HexBytesMapValue)(nil)
var _ Value = (*int32HexBytesMapValue)(nil)
var _ Getter = (*int32HexBytesMapValue)(nil)

func newInt32HexBytesMapValue(m *map[int32]HexBytes, sep *string) *int32HexBytesMapValue {
	s := &int32HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32HexBytesMapValue) Type() string { return "map[int32]HexBytes" }

func (v *int32HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- int64HexBytesMapValue.
type int64HexBytesMapValue struct {
	value     *map[int64]HexBytes
	separator string
}

var _ RepeatableFlag = (*int64HexBytesMapValue)(nil)
var _ Value = (*int64HexBytesMapValue)(nil)
var _ Getter = (*int64HexBytesMapValue)(nil)

func newInt64HexBytesMapValue(m *map[int64]HexBytes, sep *string) *int64HexBytesMapValue {
	s := &int64HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64HexBytesMapValue) Type() string { return "map[int64]HexBytes" }

func (v *int64HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- uintHexBytesMapValue.
type uintHexBytesMapValue struct {
	value     *map[uint]HexBytes
	separator string
}

var _ RepeatableFlag = (*uintHexBytesMapValue)(nil)
var _ Value = (*uintHexBytesMapValue)(nil)
var _ Getter = (*uintHexBytesMapValue)(nil)

func newUintHexBytesMapValue(m *map[uint]HexBytes, sep *string) *uintHexBytesMapValue {
	s := &uintHexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintHexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintHexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintHexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintHexBytesMapValue) Type() string { return "map[uint]HexBytes" }

func (v *uintHexBytesMapValue) IsCumulative() bool {
	return true
}

// -- uint8HexBytesMapValue.
type uint8HexBytesMapValue struct {
	value     *map[uint8]HexBytes
	separator string
}

var _ RepeatableFlag = (*uint8HexBytesMapValue)(nil)
var _ Value = (*uint8HexBytesMapValue)(nil)
var _ Getter = (*uint8HexBytesMapValue)(nil)

func newUint8HexBytesMapValue(m *map[uint8]HexBytes, sep *string) *uint8HexBytesMapValue {
	s := &uint8HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8HexBytesMapValue) Type() string { return "map[uint8]HexBytes" }

func (v *uint8HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- uint16HexBytesMapValue.
type uint16HexBytesMapValue struct {
	value     *map[uint16]HexBytes
	separator string
}

var _ RepeatableFlag = (*uint16HexBytesMapValue)(nil)
var _ Value = (*uint16HexBytesMapValue)(nil)
var _ Getter = (*uint16HexBytesMapValue)(nil)

func newUint16HexBytesMapValue(m *map[uint16]HexBytes, sep *string) *uint16HexBytesMapValue {
	s := &uint16HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16HexBytesMapValue) Type() string { return "map[uint16]HexBytes" }

func (v *uint16HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- uint32HexBytesMapValue.
type uint32HexBytesMapValue struct {
	value     *map[uint32]HexBytes
	separator string
}

var _ RepeatableFlag = (*uint32HexBytesMapValue)(nil)
var _ Value = (*uint32HexBytesMapValue)(nil)
var _ Getter = (*uint32HexBytesMapValue)(nil)

func newUint32HexBytesMapValue(m *map[uint32]HexBytes, sep *string) *uint32HexBytesMapValue {
	s := &uint32HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32HexBytesMapValue) Type() string { return "map[uint32]HexBytes" }

func (v *uint32HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- uint64HexBytesMapValue.
type uint64HexBytesMapValue struct {
	value     *map[uint64]HexBytes
	separator string
}

var _ RepeatableFlag = (*uint64HexBytesMapValue)(nil)
var _ Value = (*uint64HexBytesMapValue)(nil)
var _ Getter = (*uint64HexBytesMapValue)(nil)

func newUint64HexBytesMapValue(m *map[uint64]HexBytes, sep *string) *uint64HexBytesMapValue {
	s := &uint64HexBytesMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64HexBytesMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := hex.DecodeString(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64HexBytesMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64HexBytesMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64HexBytesMapValue) Type() string { return "map[uint64]HexBytes" }

func (v *uint64HexBytesMapValue) IsCumulative() bool {
	return true
}

// -- *regexp.Regexp Value.
type regexpValue struct {
	value **regexp.Regexp
}

var _ Value = (*regexpValue)(nil)
var _ Getter = (*regexpValue)(nil)

func newRegexpValue(p **regexp.Regexp) *regexpValue {
	return &regexpValue{value: p}
}

func (v *regexpValue) Set(s string) error {

	parsed, err := regexp.Compile(s)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *regexpValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *regexpValue) String() string {
	if v != nil && v.value != nil {

		return (**v.value).String()
	}

	return ""
}

func (v *regexpValue) Type() string { return "regexp" }

// -- *regexp.RegexpSlice Value

type regexpSliceValue struct {
	value     *[]*regexp.Regexp
	changed   bool
	separator string
}

var _ RepeatableFlag = (*regexpSliceValue)(nil)
var _ Value = (*regexpSliceValue)(nil)
var _ Getter = (*regexpSliceValue)(nil)

func newRegexpSliceValue(slice *[]*regexp.Regexp, sep *string) *regexpSliceValue {
	s := &regexpSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *regexpSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]*regexp.Regexp, len(ss))
	for i, s := range ss {
		parsed, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *regexpSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]*regexp.Regexp)(nil)
}

func (v *regexpSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newRegexpValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *regexpSliceValue) Type() string { return "regexpSlice" }

func (v *regexpSliceValue) IsCumulative() bool {
	return true
}

// -- stringRegexpMapValue.
type stringRegexpMapValue struct {
	value     *map[string]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*stringRegexpMapValue)(nil)
var _ Value = (*stringRegexpMapValue)(nil)
var _ Getter = (*stringRegexpMapValue)(nil)

func newStringRegexpMapValue(m *map[string]*regexp.Regexp, sep *string) *stringRegexpMapValue {
	s := &stringRegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringRegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringRegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringRegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringRegexpMapValue) Type() string { return "map[string]*regexp.Regexp" }

func (v *stringRegexpMapValue) IsCumulative() bool {
	return true
}

// -- intRegexpMapValue.
type intRegexpMapValue struct {
	value     *map[int]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*intRegexpMapValue)(nil)
var _ Value = (*intRegexpMapValue)(nil)
var _ Getter = (*intRegexpMapValue)(nil)

func newIntRegexpMapValue(m *map[int]*regexp.Regexp, sep *string) *intRegexpMapValue {
	s := &intRegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intRegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intRegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intRegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intRegexpMapValue) Type() string { return "map[int]*regexp.Regexp" }

func (v *intRegexpMapValue) IsCumulative() bool {
	return true
}

// -- int8RegexpMapValue.
type int8RegexpMapValue struct {
	value     *map[int8]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*int8RegexpMapValue)(nil)
var _ Value = (*int8RegexpMapValue)(nil)
var _ Getter = (*int8RegexpMapValue)(nil)

func newInt8RegexpMapValue(m *map[int8]*regexp.Regexp, sep *string) *int8RegexpMapValue {
	s := &int8RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8RegexpMapValue) Type() string { return "map[int8]*regexp.Regexp" }

func (v *int8RegexpMapValue) IsCumulative() bool {
	return true
}

// -- int16RegexpMapValue.
type int16RegexpMapValue struct {
	value     *map[int16]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*int16RegexpMapValue)(nil)
var _ Value = (*int16RegexpMapValue)(nil)
var _ Getter = (*int16RegexpMapValue)(nil)

func newInt16RegexpMapValue(m *map[int16]*regexp.Regexp, sep *string) *int16RegexpMapValue {
	s := &int16RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16RegexpMapValue) Type() string { return "map[int16]*regexp.Regexp" }

func (v *int16RegexpMapValue) IsCumulative() bool {
	return true
}

// -- int32RegexpMapValue.
type int32RegexpMapValue struct {
	value     *map[int32]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*int32RegexpMapValue)(nil)
var _ Value = (*int32RegexpMapValue)(nil)
var _ Getter = (*int32RegexpMapValue)(nil)

func newInt32RegexpMapValue(m *map[int32]*regexp.Regexp, sep *string) *int32RegexpMapValue {
	s := &int32RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32RegexpMapValue) Type() string { return "map[int32]*regexp.Regexp" }

func (v *int32RegexpMapValue) IsCumulative() bool {
	return true
}

// -- int64RegexpMapValue.
type int64RegexpMapValue struct {
	value     *map[int64]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*int64RegexpMapValue)(nil)
var _ Value = (*int64RegexpMapValue)(nil)
var _ Getter = (*int64RegexpMapValue)(nil)

func newInt64RegexpMapValue(m *map[int64]*regexp.Regexp, sep *string) *int64RegexpMapValue {
	s := &int64RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64RegexpMapValue) Type() string { return "map[int64]*regexp.Regexp" }

func (v *int64RegexpMapValue) IsCumulative() bool {
	return true
}

// -- uintRegexpMapValue.
type uintRegexpMapValue struct {
	value     *map[uint]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*uintRegexpMapValue)(nil)
var _ Value = (*uintRegexpMapValue)(nil)
var _ Getter = (*uintRegexpMapValue)(nil)

func newUintRegexpMapValue(m *map[uint]*regexp.Regexp, sep *string) *uintRegexpMapValue {
	s := &uintRegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintRegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintRegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintRegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintRegexpMapValue) Type() string { return "map[uint]*regexp.Regexp" }

func (v *uintRegexpMapValue) IsCumulative() bool {
	return true
}

// -- uint8RegexpMapValue.
type uint8RegexpMapValue struct {
	value     *map[uint8]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*uint8RegexpMapValue)(nil)
var _ Value = (*uint8RegexpMapValue)(nil)
var _ Getter = (*uint8RegexpMapValue)(nil)

func newUint8RegexpMapValue(m *map[uint8]*regexp.Regexp, sep *string) *uint8RegexpMapValue {
	s := &uint8RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8RegexpMapValue) Type() string { return "map[uint8]*regexp.Regexp" }

func (v *uint8RegexpMapValue) IsCumulative() bool {
	return true
}

// -- uint16RegexpMapValue.
type uint16RegexpMapValue struct {
	value     *map[uint16]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*uint16RegexpMapValue)(nil)
var _ Value = (*uint16RegexpMapValue)(nil)
var _ Getter = (*uint16RegexpMapValue)(nil)

func newUint16RegexpMapValue(m *map[uint16]*regexp.Regexp, sep *string) *uint16RegexpMapValue {
	s := &uint16RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16RegexpMapValue) Type() string { return "map[uint16]*regexp.Regexp" }

func (v *uint16RegexpMapValue) IsCumulative() bool {
	return true
}

// -- uint32RegexpMapValue.
type uint32RegexpMapValue struct {
	value     *map[uint32]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*uint32RegexpMapValue)(nil)
var _ Value = (*uint32RegexpMapValue)(nil)
var _ Getter = (*uint32RegexpMapValue)(nil)

func newUint32RegexpMapValue(m *map[uint32]*regexp.Regexp, sep *string) *uint32RegexpMapValue {
	s := &uint32RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32RegexpMapValue) Type() string { return "map[uint32]*regexp.Regexp" }

func (v *uint32RegexpMapValue) IsCumulative() bool {
	return true
}

// -- uint64RegexpMapValue.
type uint64RegexpMapValue struct {
	value     *map[uint64]*regexp.Regexp
	separator string
}

var _ RepeatableFlag = (*uint64RegexpMapValue)(nil)
var _ Value = (*uint64RegexpMapValue)(nil)
var _ Getter = (*uint64RegexpMapValue)(nil)

func newUint64RegexpMapValue(m *map[uint64]*regexp.Regexp, sep *string) *uint64RegexpMapValue {
	s := &uint64RegexpMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64RegexpMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := regexp.Compile(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64RegexpMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64RegexpMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64RegexpMapValue) Type() string { return "map[uint64]*regexp.Regexp" }

func (v *uint64RegexpMapValue) IsCumulative() bool {
	return true
}

// -- net.TCPAddr Value.
type tcpAddrValue struct {
	value *net.TCPAddr
}

var _ Value = (*tcpAddrValue)(nil)
var _ Getter = (*tcpAddrValue)(nil)

func newTCPAddrValue(p *net.TCPAddr) *tcpAddrValue {
	return &tcpAddrValue{value: p}
}

func (v *tcpAddrValue) Set(s string) error {

	parsed, err := parseTCPAddr(s)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *tcpAddrValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *tcpAddrValue) String() string {
	if v != nil && v.value != nil {

		return v.value.String()
	}

	return ""
}

func (v *tcpAddrValue) Type() string { return "tcpAddr" }

// -- net.TCPAddrSlice Value

type tcpAddrSliceValue struct {
	value     *[]net.TCPAddr
	changed   bool
	separator string
}

var _ RepeatableFlag = (*tcpAddrSliceValue)(nil)
var _ Value = (*tcpAddrSliceValue)(nil)
var _ Getter = (*tcpAddrSliceValue)(nil)

func newTCPAddrSliceValue(slice *[]net.TCPAddr, sep *string) *tcpAddrSliceValue {
	s := &tcpAddrSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *tcpAddrSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]net.TCPAddr, len(ss))
	for i, s := range ss {
		parsed, err := parseTCPAddr(s)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *tcpAddrSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]net.TCPAddr)(nil)
}

func (v *tcpAddrSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newTCPAddrValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *tcpAddrSliceValue) Type() string { return "tcpAddrSlice" }

func (v *tcpAddrSliceValue) IsCumulative() bool {
	return true
}

// -- net.IPNet Value.
type ipNetValue struct {
	value *net.IPNet
}

var _ Value = (*ipNetValue)(nil)
var _ Getter = (*ipNetValue)(nil)

func newIPNetValue(p *net.IPNet) *ipNetValue {
	return &ipNetValue{value: p}
}

func (v *ipNetValue) Set(s string) error {

	parsed, err := parseIPNet(s)
	if err == nil {

		*v.value = parsed

		return nil
	}

	return err

}

func (v *ipNetValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return nil
}

func (v *ipNetValue) String() string {
	if v != nil && v.value != nil {

		return v.value.String()
	}

	return ""
}

func (v *ipNetValue) Type() string { return "ipNet" }

// -- net.IPNetSlice Value

type ipNetSliceValue struct {
	value     *[]net.IPNet
	changed   bool
	separator string
}

var _ RepeatableFlag = (*ipNetSliceValue)(nil)
var _ Value = (*ipNetSliceValue)(nil)
var _ Getter = (*ipNetSliceValue)(nil)

func newIPNetSliceValue(slice *[]net.IPNet, sep *string) *ipNetSliceValue {
	s := &ipNetSliceValue{
		value: slice,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *ipNetSliceValue) Set(raw string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var ss []string
	if separator == "none" {
		ss = []string{raw}
	} else {
		ss = strings.Split(raw, separator)
	}

	out := make([]net.IPNet, len(ss))
	for i, s := range ss {
		parsed, err := parseIPNet(s)
		if err != nil {
			return err
		}

		out[i] = parsed

	}

	if !v.changed {
		*v.value = out
	} else {
		*v.value = append(*v.value, out...)
	}
	v.changed = true

	return nil
}

func (v *ipNetSliceValue) Get() any {
	if v != nil && v.value != nil {

		return *v.value
	}

	return ([]net.IPNet)(nil)
}

func (v *ipNetSliceValue) String() string {
	if v == nil || v.value == nil {

		return "[]"
	}
	out := make([]string, 0, len(*v.value))
	for _, elem := range *v.value {
		out = append(out, newIPNetValue(&elem).String())
	}

	return "[" + strings.Join(out, ",") + "]"
}

func (v *ipNetSliceValue) Type() string { return "ipNetSlice" }

func (v *ipNetSliceValue) IsCumulative() bool {
	return true
}

// -- stringIPNetMapValue.
type stringIPNetMapValue struct {
	value     *map[string]net.IPNet
	separator string
}

var _ RepeatableFlag = (*stringIPNetMapValue)(nil)
var _ Value = (*stringIPNetMapValue)(nil)
var _ Getter = (*stringIPNetMapValue)(nil)

func newStringIPNetMapValue(m *map[string]net.IPNet, sep *string) *stringIPNetMapValue {
	s := &stringIPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *stringIPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		key := s

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *stringIPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *stringIPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *stringIPNetMapValue) Type() string { return "map[string]net.IPNet" }

func (v *stringIPNetMapValue) IsCumulative() bool {
	return true
}

// -- intIPNetMapValue.
type intIPNetMapValue struct {
	value     *map[int]net.IPNet
	separator string
}

var _ RepeatableFlag = (*intIPNetMapValue)(nil)
var _ Value = (*intIPNetMapValue)(nil)
var _ Getter = (*intIPNetMapValue)(nil)

func newIntIPNetMapValue(m *map[int]net.IPNet, sep *string) *intIPNetMapValue {
	s := &intIPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *intIPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := (int)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *intIPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *intIPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *intIPNetMapValue) Type() string { return "map[int]net.IPNet" }

func (v *intIPNetMapValue) IsCumulative() bool {
	return true
}

// -- int8IPNetMapValue.
type int8IPNetMapValue struct {
	value     *map[int8]net.IPNet
	separator string
}

var _ RepeatableFlag = (*int8IPNetMapValue)(nil)
var _ Value = (*int8IPNetMapValue)(nil)
var _ Getter = (*int8IPNetMapValue)(nil)

func newInt8IPNetMapValue(m *map[int8]net.IPNet, sep *string) *int8IPNetMapValue {
	s := &int8IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int8IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 8)
		if err != nil {
			return err
		}

		key := (int8)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int8IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int8IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int8IPNetMapValue) Type() string { return "map[int8]net.IPNet" }

func (v *int8IPNetMapValue) IsCumulative() bool {
	return true
}

// -- int16IPNetMapValue.
type int16IPNetMapValue struct {
	value     *map[int16]net.IPNet
	separator string
}

var _ RepeatableFlag = (*int16IPNetMapValue)(nil)
var _ Value = (*int16IPNetMapValue)(nil)
var _ Getter = (*int16IPNetMapValue)(nil)

func newInt16IPNetMapValue(m *map[int16]net.IPNet, sep *string) *int16IPNetMapValue {
	s := &int16IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int16IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 16)
		if err != nil {
			return err
		}

		key := (int16)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int16IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int16IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int16IPNetMapValue) Type() string { return "map[int16]net.IPNet" }

func (v *int16IPNetMapValue) IsCumulative() bool {
	return true
}

// -- int32IPNetMapValue.
type int32IPNetMapValue struct {
	value     *map[int32]net.IPNet
	separator string
}

var _ RepeatableFlag = (*int32IPNetMapValue)(nil)
var _ Value = (*int32IPNetMapValue)(nil)
var _ Getter = (*int32IPNetMapValue)(nil)

func newInt32IPNetMapValue(m *map[int32]net.IPNet, sep *string) *int32IPNetMapValue {
	s := &int32IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int32IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 32)
		if err != nil {
			return err
		}

		key := (int32)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int32IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int32IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int32IPNetMapValue) Type() string { return "map[int32]net.IPNet" }

func (v *int32IPNetMapValue) IsCumulative() bool {
	return true
}

// -- int64IPNetMapValue.
type int64IPNetMapValue struct {
	value     *map[int64]net.IPNet
	separator string
}

var _ RepeatableFlag = (*int64IPNetMapValue)(nil)
var _ Value = (*int64IPNetMapValue)(nil)
var _ Getter = (*int64IPNetMapValue)(nil)

func newInt64IPNetMapValue(m *map[int64]net.IPNet, sep *string) *int64IPNetMapValue {
	s := &int64IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *int64IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *int64IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *int64IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *int64IPNetMapValue) Type() string { return "map[int64]net.IPNet" }

func (v *int64IPNetMapValue) IsCumulative() bool {
	return true
}

// -- uintIPNetMapValue.
type uintIPNetMapValue struct {
	value     *map[uint]net.IPNet
	separator string
}

var _ RepeatableFlag = (*uintIPNetMapValue)(nil)
var _ Value = (*uintIPNetMapValue)(nil)
var _ Getter = (*uintIPNetMapValue)(nil)

func newUintIPNetMapValue(m *map[uint]net.IPNet, sep *string) *uintIPNetMapValue {
	s := &uintIPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uintIPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := (uint)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uintIPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uintIPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uintIPNetMapValue) Type() string { return "map[uint]net.IPNet" }

func (v *uintIPNetMapValue) IsCumulative() bool {
	return true
}

// -- uint8IPNetMapValue.
type uint8IPNetMapValue struct {
	value     *map[uint8]net.IPNet
	separator string
}

var _ RepeatableFlag = (*uint8IPNetMapValue)(nil)
var _ Value = (*uint8IPNetMapValue)(nil)
var _ Getter = (*uint8IPNetMapValue)(nil)

func newUint8IPNetMapValue(m *map[uint8]net.IPNet, sep *string) *uint8IPNetMapValue {
	s := &uint8IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint8IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 8)
		if err != nil {
			return err
		}

		key := (uint8)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint8IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint8IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint8IPNetMapValue) Type() string { return "map[uint8]net.IPNet" }

func (v *uint8IPNetMapValue) IsCumulative() bool {
	return true
}

// -- uint16IPNetMapValue.
type uint16IPNetMapValue struct {
	value     *map[uint16]net.IPNet
	separator string
}

var _ RepeatableFlag = (*uint16IPNetMapValue)(nil)
var _ Value = (*uint16IPNetMapValue)(nil)
var _ Getter = (*uint16IPNetMapValue)(nil)

func newUint16IPNetMapValue(m *map[uint16]net.IPNet, sep *string) *uint16IPNetMapValue {
	s := &uint16IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint16IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 16)
		if err != nil {
			return err
		}

		key := (uint16)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint16IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint16IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint16IPNetMapValue) Type() string { return "map[uint16]net.IPNet" }

func (v *uint16IPNetMapValue) IsCumulative() bool {
	return true
}

// -- uint32IPNetMapValue.
type uint32IPNetMapValue struct {
	value     *map[uint32]net.IPNet
	separator string
}

var _ RepeatableFlag = (*uint32IPNetMapValue)(nil)
var _ Value = (*uint32IPNetMapValue)(nil)
var _ Getter = (*uint32IPNetMapValue)(nil)

func newUint32IPNetMapValue(m *map[uint32]net.IPNet, sep *string) *uint32IPNetMapValue {
	s := &uint32IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint32IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 32)
		if err != nil {
			return err
		}

		key := (uint32)(parsedKey)

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint32IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint32IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint32IPNetMapValue) Type() string { return "map[uint32]net.IPNet" }

func (v *uint32IPNetMapValue) IsCumulative() bool {
	return true
}

// -- uint64IPNetMapValue.
type uint64IPNetMapValue struct {
	value     *map[uint64]net.IPNet
	separator string
}

var _ RepeatableFlag = (*uint64IPNetMapValue)(nil)
var _ Value = (*uint64IPNetMapValue)(nil)
var _ Getter = (*uint64IPNetMapValue)(nil)

func newUint64IPNetMapValue(m *map[uint64]net.IPNet, sep *string) *uint64IPNetMapValue {
	s := &uint64IPNetMapValue{
		value: m,
	}
	if sep != nil {
		s.separator = *sep
	}

	return s
}

func (v *uint64IPNetMapValue) Set(val string) error {
	separator := v.separator
	if separator == "" {
		separator = "," // Default separator
	}

	var values []string
	if separator == "none" {
		values = []string{val}
	} else {
		values = strings.Split(val, separator)
	}

	for _, s := range values {
		ss := strings.Split(s, ":")
		if len(ss) < 2 {
			return errors.New("invalid map flag syntax, use -map=key1:val1")
		}

		s = ss[0]

		parsedKey, err := strconv.ParseUint(s, 0, 64)
		if err != nil {
			return err
		}

		key := parsedKey

		s = ss[1]

		parsedVal, err := parseIPNet(s)
		if err != nil {
			return err
		}

		val := parsedVal

		(*v.value)[key] = val
	}

	return nil
}

func (v *uint64IPNetMapValue) Get() any {
	if v != nil && v.value != nil {
		return *v.value
	}

	return nil
}

func (v *uint64IPNetMapValue) String() string {
	if v != nil && v.value != nil && len(*v.value) > 0 {
		return fmt.Sprintf("%v", *v.value)
	}

	return ""
}

func (v *uint64IPNetMapValue) Type() string { return "map[uint64]net.IPNet" }

func (v *uint64IPNetMapValue) IsCumulative() bool {
	return true
}
