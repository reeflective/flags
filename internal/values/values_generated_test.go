package values

// This file is autogenerated by "go generate .". Do not modify.

import (
	// "net"
	// "regexp".
	"testing"

	// "github.com/reeflective/flags/internal/interfaces"
	// "github.com/reeflective/flags/types".
	"github.com/stretchr/testify/assert"
)

func TestStringValue_Zero(t *testing.T) {
	t.Parallel()

	nilValue := new(stringValue)
	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*stringValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringValue(t *testing.T) {
	t.Parallel()
	t.Run("in: string", func(t *testing.T) {
		t.Parallel()

		a := new(string)
		v := newStringValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("string")
		assert.NoError(t, err)
		assert.Equal(t, "string", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "string", v.Type())
	})
}

func TestStringSliceValue_Zero(t *testing.T) {
	t.Parallel()

	nilValue := new(stringSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*stringSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringStringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue stringStringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*stringStringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntStringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue intStringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*intStringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int8StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int8StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int16StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int16StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int32StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int32StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int64StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int64StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintStringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uintStringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uintStringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint8StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint8StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint16StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint16StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint32StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint32StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64StringMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint64StringMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint64StringMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringSliceValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1,val2 val3,val4]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := new([]string)
		v := newStringSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("val1,val2")
		assert.NoError(t, err)
		err = v.Set("val3,val4")
		assert.NoError(t, err)
		assert.Equal(t, "[val1,val2,val3,val4]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "stringSlice", v.Type())
	})
}

func TestStringStringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[string]string)
		v := newStringStringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("XVlBzval1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("gbaiC:val1")
		assert.NoError(t, err)
		err = v.Set("MRAjWval2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("whTHc:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[string]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[string]string)
		v := newStringStringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("tcuAx")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("hxKQF:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[string]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestIntStringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int]string)
		v := newIntStringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("5val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("0:val1")
		assert.NoError(t, err)
		err = v.Set("3val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("7:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int]string)
		v := newIntStringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("5")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("4:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestInt8StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int8]string)
		v := newInt8StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("7:val1")
		assert.NoError(t, err)
		err = v.Set("5val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("2:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int8]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int8]string)
		v := newInt8StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("5")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("2:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int8]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestInt16StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int16]string)
		v := newInt16StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("3:val1")
		assert.NoError(t, err)
		err = v.Set("1val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("3:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int16]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int16]string)
		v := newInt16StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("6")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("4:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int16]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestInt32StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int32]string)
		v := newInt32StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("7val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("1:val1")
		assert.NoError(t, err)
		err = v.Set("5val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("1:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int32]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int32]string)
		v := newInt32StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("5")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("7:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int32]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestInt64StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int64]string)
		v := newInt64StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("1:val1")
		assert.NoError(t, err)
		err = v.Set("0val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("2:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int64]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int64]string)
		v := newInt64StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("7")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("3:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int64]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestUintStringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint]string)
		v := newUintStringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("3val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("6:val1")
		assert.NoError(t, err)
		err = v.Set("5val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("4:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint]string)
		v := newUintStringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("4:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestUint8StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint8]string)
		v := newUint8StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("2:val1")
		assert.NoError(t, err)
		err = v.Set("7val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("2:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint8]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint8]string)
		v := newUint8StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("3")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("0:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint8]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestUint16StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint16]string)
		v := newUint16StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("6:val1")
		assert.NoError(t, err)
		err = v.Set("7val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("6:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint16]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint16]string)
		v := newUint16StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("7:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint16]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestUint32StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint32]string)
		v := newUint32StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("4val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("4:val1")
		assert.NoError(t, err)
		err = v.Set("7val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("1:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint32]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint32]string)
		v := newUint32StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("5:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint32]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestUint64StringMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [val1 val2]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint64]string)
		v := newUint64StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1val1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val1")
		assert.Error(t, err)
		err = v.Set("3:val1")
		assert.NoError(t, err)
		err = v.Set("1val2")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":val2")
		assert.Error(t, err)
		err = v.Set("3:val2")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint64]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: []", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint64]string)
		v := newUint64StringMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("3")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":")
		assert.Error(t, err)
		err = v.Set("2:")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint64]string", v.Type())
		assert.NotEmpty(t, v.String())
	})
}

func TestBoolValue_Zero(t *testing.T) {
	t.Parallel()

	nilValue := new(boolValue)
	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*boolValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestBoolValue(t *testing.T) {
	t.Parallel()
	t.Run("in: true", func(t *testing.T) {
		t.Parallel()

		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("true")
		assert.NoError(t, err)
		assert.Equal(t, "true", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: false", func(t *testing.T) {
		t.Parallel()

		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("false")
		assert.NoError(t, err)
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: 1", func(t *testing.T) {
		t.Parallel()

		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("1")
		assert.NoError(t, err)
		assert.Equal(t, "true", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: 0", func(t *testing.T) {
		t.Parallel()

		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0")
		assert.NoError(t, err)
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: unexpected", func(t *testing.T) {
		t.Parallel()

		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
}

func TestBoolSliceValue_Zero(t *testing.T) {
	t.Parallel()

	nilValue := new(boolSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*boolSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringBoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue stringBoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*stringBoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntBoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue intBoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*intBoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int8BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int8BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int16BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int16BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int32BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int32BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int64BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int64BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintBoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uintBoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uintBoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint8BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint8BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint16BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint16BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint32BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint32BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64BoolMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint64BoolMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint64BoolMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestBoolSliceValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true,false true]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := new([]bool)
		v := newBoolSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("true,false")
		assert.NoError(t, err)
		err = v.Set("true")
		assert.NoError(t, err)
		assert.Equal(t, "[true,false,true]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "boolSlice", v.Type())
	})
	t.Run("in: [true,unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := new([]bool)
		v := newBoolSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("true,unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "boolSlice", v.Type())
	})
}

func TestStringBoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[string]bool)
		v := newStringBoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("gmotatrue")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("FetHs:true")
		assert.NoError(t, err)
		err = v.Set("bZRjxfalse")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("Awnwe:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[string]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[string]bool)
		v := newStringBoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("krBEmunexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("fdzdc:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[string]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestIntBoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int]bool)
		v := newIntBoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("6true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("2:true")
		assert.NoError(t, err)
		err = v.Set("5false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("7:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int]bool)
		v := newIntBoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("6:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt8BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int8]bool)
		v := newInt8BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("5true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("6:true")
		assert.NoError(t, err)
		err = v.Set("3false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("5:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int8]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int8]bool)
		v := newInt8BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("4unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("7:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int8]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt16BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int16]bool)
		v := newInt16BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("5true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("6:true")
		assert.NoError(t, err)
		err = v.Set("3false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("5:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int16]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int16]bool)
		v := newInt16BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("2:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int16]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt32BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int32]bool)
		v := newInt32BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("7:true")
		assert.NoError(t, err)
		err = v.Set("0false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("3:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int32]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int32]bool)
		v := newInt32BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("4unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("4:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int32]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt64BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int64]bool)
		v := newInt64BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("7:true")
		assert.NoError(t, err)
		err = v.Set("4false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("2:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int64]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int64]bool)
		v := newInt64BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("3unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("4:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int64]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUintBoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint]bool)
		v := newUintBoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("7:true")
		assert.NoError(t, err)
		err = v.Set("4false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("4:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint]bool)
		v := newUintBoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("7:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint8BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint8]bool)
		v := newUint8BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("2:true")
		assert.NoError(t, err)
		err = v.Set("2false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("2:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint8]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint8]bool)
		v := newUint8BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("7unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("7:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint8]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint16BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint16]bool)
		v := newUint16BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("2:true")
		assert.NoError(t, err)
		err = v.Set("6false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("7:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint16]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint16]bool)
		v := newUint16BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("6unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("0:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint16]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint32BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint32]bool)
		v := newUint32BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("7true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("0:true")
		assert.NoError(t, err)
		err = v.Set("6false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("6:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint32]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint32]bool)
		v := newUint32BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("7unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("0:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint32]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint64BoolMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [true false]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint64]bool)
		v := newUint64BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0true")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":true")
		assert.Error(t, err)
		err = v.Set("2:true")
		assert.NoError(t, err)
		err = v.Set("1false")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":false")
		assert.Error(t, err)
		err = v.Set("7:false")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint64]bool", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [unexpected]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint64]bool)
		v := newUint64BoolMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("3unexpected")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":unexpected")
		assert.Error(t, err)
		err = v.Set("7:unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint64]bool", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUintValue_Zero(t *testing.T) {
	t.Parallel()

	nilValue := new(uintValue)
	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uintValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintValue(t *testing.T) {
	t.Parallel()
	t.Run("in: 18446744073709551615", func(t *testing.T) {
		t.Parallel()

		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551615")
		assert.NoError(t, err)
		assert.Equal(t, "18446744073709551615", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: 18446744073709551616", func(t *testing.T) {
		t.Parallel()

		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551616")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"18446744073709551616\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		t.Parallel()

		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		t.Parallel()

		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
}

func TestUintSliceValue_Zero(t *testing.T) {
	t.Parallel()

	nilValue := new(uintSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uintSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringUintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue stringUintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*stringUintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntUintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue intUintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*intUintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int8UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int8UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int16UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int16UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int32UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int32UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue int64UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*int64UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintUintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uintUintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uintUintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint8UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint8UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint16UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint16UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint32UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint32UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64UintMapValue_Zero(t *testing.T) {
	t.Parallel()

	var nilValue uint64UintMapValue

	assert.Empty(t, nilValue.String())
	assert.Nil(t, nilValue.Get())

	nilObj := (*uint64UintMapValue)(nil)
	assert.Empty(t, nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintSliceValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10,20 0]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := new([]uint)
		v := newUintSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.NoError(t, err)
		err = v.Set("0")
		assert.NoError(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uintSlice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := new([]uint)
		v := newUintSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uintSlice", v.Type())
	})
}

func TestStringUintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[string]uint)
		v := newStringUintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("sbOJi10")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("FQGZs:10")
		assert.NoError(t, err)
		err = v.Set("nwTKS20")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("mVoiG:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[string]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[string]uint)
		v := newStringUintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("LOpbU-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set("OpEdK:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[string]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestIntUintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int]uint)
		v := newIntUintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("010")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("3:10")
		assert.NoError(t, err)
		err = v.Set("720")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("0:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int]uint)
		v := newIntUintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("6-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("4:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt8UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int8]uint)
		v := newInt8UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("310")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("7:10")
		assert.NoError(t, err)
		err = v.Set("520")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("4:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int8]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int8]uint)
		v := newInt8UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("3-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("5:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int8]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt16UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int16]uint)
		v := newInt16UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("510")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("3:10")
		assert.NoError(t, err)
		err = v.Set("120")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("1:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int16]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int16]uint)
		v := newInt16UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("6-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("4:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int16]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt32UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int32]uint)
		v := newInt32UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("210")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("0:10")
		assert.NoError(t, err)
		err = v.Set("020")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("5:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int32]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int32]uint)
		v := newInt32UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("5:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int32]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestInt64UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int64]uint)
		v := newInt64UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("510")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("4:10")
		assert.NoError(t, err)
		err = v.Set("420")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("7:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int64]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[int64]uint)
		v := newInt64UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("0:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[int64]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUintUintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint]uint)
		v := newUintUintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("410")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("7:10")
		assert.NoError(t, err)
		err = v.Set("520")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("5:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint]uint)
		v := newUintUintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("4-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("0:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint8UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint8]uint)
		v := newUint8UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("710")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("5:10")
		assert.NoError(t, err)
		err = v.Set("520")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("1:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint8]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint8]uint)
		v := newUint8UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("4-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("5:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint8]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint16UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint16]uint)
		v := newUint16UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("510")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("7:10")
		assert.NoError(t, err)
		err = v.Set("720")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("6:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint16]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint16]uint)
		v := newUint16UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("6:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint16]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint32UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint32]uint)
		v := newUint32UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("410")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("0:10")
		assert.NoError(t, err)
		err = v.Set("420")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("5:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint32]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint32]uint)
		v := newUint32UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("3-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("3:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint32]uint", v.Type())
		assert.Empty(t, v.String())
	})
}

func TestUint64UintMapValue(t *testing.T) {
	t.Parallel()
	t.Run("in: [10 20]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint64]uint)
		v := newUint64UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("510")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":10")
		assert.Error(t, err)
		err = v.Set("4:10")
		assert.NoError(t, err)
		err = v.Set("420")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":20")
		assert.Error(t, err)
		err = v.Set("7:20")
		assert.NoError(t, err)
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint64]uint", v.Type())
		assert.NotEmpty(t, v.String())
	})
	t.Run("in: [-1]", func(t *testing.T) {
		t.Parallel()

		var err error

		a := make(map[uint64]uint)
		v := newUint64UintMapValue(&a)
		assert.Equal(t, parseGeneratedMap(&a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("2-1")
		assert.EqualError(t, err, "invalid map flag syntax, use -map=key1:val1")
		err = v.Set(":-1")
		assert.Error(t, err)
		err = v.Set("0:-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "map[uint64]uint", v.Type())
		assert.Empty(t, v.String())
	})
}
